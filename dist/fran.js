/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-loader/lib/index.js?!./deps/arrows.es5.js":
/*!********************************************************************!*\
  !*** ./node_modules/babel-loader/lib??ref--4!./deps/arrows.es5.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, module) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _slicedToArray = function () {\n    function sliceIterator(arr, i) {\n        var _arr = [];var _n = true;var _d = false;var _e = undefined;try {\n            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n                _arr.push(_s.value);if (i && _arr.length === i) break;\n            }\n        } catch (err) {\n            _d = true;_e = err;\n        } finally {\n            try {\n                if (!_n && _i[\"return\"]) _i[\"return\"]();\n            } finally {\n                if (_d) throw _e;\n            }\n        }return _arr;\n    }return function (arr, i) {\n        if (Array.isArray(arr)) {\n            return arr;\n        } else if (Symbol.iterator in Object(arr)) {\n            return sliceIterator(arr, i);\n        } else {\n            throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n        }\n    };\n}();\n\nvar _get = function get(object, property, receiver) {\n    if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {\n        var parent = Object.getPrototypeOf(object);if (parent === null) {\n            return undefined;\n        } else {\n            return get(parent, property, receiver);\n        }\n    } else if (\"value\" in desc) {\n        return desc.value;\n    } else {\n        var getter = desc.get;if (getter === undefined) {\n            return undefined;\n        }return getter.call(receiver);\n    }\n};\n\nvar _createClass = function () {\n    function defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n        }\n    }return function (Constructor, protoProps, staticProps) {\n        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n    };\n}();\n\nfunction _toArray(arr) {\n    return Array.isArray(arr) ? arr : Array.from(arr);\n}\n\nfunction _possibleConstructorReturn(self, call) {\n    if (!self) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof(superClass)));\n    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\n\nvar parser = function () {\n    var t = function t(_t, e, n, s) {\n        for (n = n || {}, s = _t.length; s--; n[_t[s]] = e) {}return n;\n    },\n        e = [1, 3],\n        n = [1, 4],\n        s = [1, 5],\n        i = [1, 6],\n        r = [1, 7],\n        h = [1, 8],\n        o = [1, 9],\n        a = [2, 17],\n        c = [1, 12],\n        l = [6, 7, 13, 16, 19, 21, 23, 25, 30],\n        y = [1, 14],\n        u = [1, 20],\n        p = [16, 21],\n        f = [19, 21],\n        g = [1, 48],\n        _ = { trace: function trace() {}, yy: {}, symbols_: { error: 2, top: 3, type: 4, annotations: 5, EOF: 6, \"~>\": 7, IDENT: 8, sum_tail: 9, _: 10, \"'\": 11, \"[\": 12, \"]\": 13, \"(\": 14, types: 15, \")\": 16, \"<\": 17, named_types: 18, \">\": 19, \"{\": 20, \"}\": 21, \"+\": 22, \",\": 23, \":\": 24, \"\\\\\\\\\": 25, bounds: 26, throws: 27, bound: 28, bound_tail: 29, \"<=\": 30, $accept: 0, $end: 1 }, terminals_: { 2: \"error\", 6: \"EOF\", 7: \"~>\", 8: \"IDENT\", 10: \"_\", 11: \"'\", 12: \"[\", 13: \"]\", 14: \"(\", 16: \")\", 17: \"<\", 19: \">\", 20: \"{\", 21: \"}\", 22: \"+\", 23: \",\", 24: \":\", 25: \"\\\\\\\\\", 30: \"<=\" }, productions_: [0, [3, 3], [3, 5], [4, 1], [4, 2], [4, 1], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [9, 2], [9, 3], [15, 1], [15, 3], [18, 3], [18, 5], [5, 0], [5, 6], [26, 2], [26, 3], [26, 4], [27, 2], [27, 3], [28, 3], [29, 2], [29, 3]], performAction: function performAction(t, e, n, s, i, r, h) {\n            var o = r.length - 1;switch (i) {case 1:\n                    return [r[o - 2], r[o - 1]];case 2:\n                    return [r[o - 4], r[o - 2], r[o - 1]];case 3:\n                    this.$ = new NamedType(r[o]);break;case 4:\n                    this.$ = new SumType([new NamedType(r[o - 1])].concat(r[o]));break;case 5:\n                    this.$ = new TopType();break;case 6:\n                    this.$ = new ParamType(r[o]);break;case 7:\n                    this.$ = new ArrayType(r[o - 1]);break;case 8:\n                    this.$ = new TupleType(r[o - 1]);break;case 9:\n                    this.$ = new TaggedUnionType(m(r[o - 1]));break;case 10:\n                    this.$ = new RecordType(m(r[o - 1]));break;case 11:\n                    this.$ = [new NamedType(r[o])];break;case 12:\n                    this.$ = [new NamedType(r[o - 1])].concat(r[o]);break;case 13:case 25:\n                    this.$ = [r[o]];break;case 14:\n                    this.$ = [r[o - 2]].concat(r[o]);break;case 15:\n                    this.$ = [[r[o - 2], r[o]]];break;case 16:\n                    this.$ = [[r[o - 4], r[o - 2]]].concat(r[o]);break;case 17:\n                    this.$ = [[], []];break;case 18:\n                    this.$ = [r[o - 3], r[o - 1]];break;case 19:\n                    this.$ = [];break;case 20:\n                    this.$ = [r[o - 1]];break;case 21:\n                    this.$ = [r[o - 2]].concat(r[o - 1]);break;case 22:\n                    this.$ = [];break;case 23:\n                    this.$ = r[o - 1];break;case 24:\n                    this.$ = new Constraint(r[o - 2], r[o]);break;case 26:\n                    this.$ = [r[o - 1]].concat(r[o]);}\n        }, table: [{ 3: 1, 4: 2, 8: e, 10: n, 11: s, 12: i, 14: r, 17: h, 20: o }, { 1: [3] }, { 5: 10, 6: a, 7: [1, 11], 25: c }, t(l, [2, 3], { 9: 13, 22: y }), t(l, [2, 5]), { 8: [1, 15] }, { 4: 16, 8: e, 10: n, 11: s, 12: i, 14: r, 17: h, 20: o }, { 4: 18, 8: e, 10: n, 11: s, 12: i, 14: r, 15: 17, 17: h, 20: o }, { 8: u, 18: 19 }, { 8: u, 18: 21 }, { 6: [1, 22] }, { 4: 23, 8: e, 10: n, 11: s, 12: i, 14: r, 17: h, 20: o }, { 14: [1, 24] }, t(l, [2, 4]), { 8: [1, 25] }, t(l, [2, 6]), { 13: [1, 26] }, { 16: [1, 27] }, t(p, [2, 13], { 23: [1, 28] }), { 19: [1, 29] }, { 24: [1, 30] }, { 21: [1, 31] }, { 1: [2, 1] }, { 5: 32, 6: a, 25: c }, { 20: [1, 34], 26: 33 }, t(l, [2, 11], { 9: 35, 22: y }), t(l, [2, 7]), t(l, [2, 8]), { 4: 18, 8: e, 10: n, 11: s, 12: i, 14: r, 15: 36, 17: h, 20: o }, t(l, [2, 9]), { 4: 37, 8: e, 10: n, 11: s, 12: i, 14: r, 17: h, 20: o }, t(l, [2, 10]), { 6: [1, 38] }, { 23: [1, 39] }, { 4: 42, 8: e, 10: n, 11: s, 12: i, 14: r, 17: h, 20: o, 21: [1, 40], 28: 41 }, t(l, [2, 12]), t(p, [2, 14]), t(f, [2, 15], { 23: [1, 43] }), { 1: [2, 2] }, { 20: [1, 45], 27: 44 }, { 23: [2, 19] }, { 21: [1, 46], 23: g, 29: 47 }, { 30: [1, 49] }, { 8: u, 18: 50 }, { 16: [1, 51] }, { 4: 18, 8: e, 10: n, 11: s, 12: i, 14: r, 15: 53, 17: h, 20: o, 21: [1, 52] }, { 23: [2, 20] }, { 21: [1, 54] }, { 4: 42, 8: e, 10: n, 11: s, 12: i, 14: r, 17: h, 20: o, 28: 55 }, { 4: 56, 8: e, 10: n, 11: s, 12: i, 14: r, 17: h, 20: o }, t(f, [2, 16]), { 6: [2, 18] }, { 16: [2, 22] }, { 21: [1, 57] }, { 23: [2, 21] }, { 21: [2, 25], 23: g, 29: 58 }, t([21, 23], [2, 24]), { 16: [2, 23] }, { 21: [2, 26] }], defaultActions: { 22: [2, 1], 38: [2, 2], 40: [2, 19], 46: [2, 20], 51: [2, 18], 52: [2, 22], 54: [2, 21], 57: [2, 23], 58: [2, 26] }, parseError: function parseError(t, e) {\n            if (!e.recoverable) {\n                var n = new Error(t);throw n.hash = e, n;\n            }this.trace(t);\n        }, parse: function parse(t) {\n            var e = this,\n                n = [0],\n                s = [null],\n                i = [],\n                r = this.table,\n                h = \"\",\n                o = 0,\n                a = 0,\n                c = 0,\n                l = i.slice.call(arguments, 1),\n                y = Object.create(this.lexer),\n                u = { yy: {} };for (var p in this.yy) {\n                Object.prototype.hasOwnProperty.call(this.yy, p) && (u.yy[p] = this.yy[p]);\n            }y.setInput(t, u.yy), u.yy.lexer = y, u.yy.parser = this, void 0 === y.yylloc && (y.yylloc = {});var f = y.yylloc;i.push(f);var g = y.options && y.options.ranges;\"function\" == typeof u.yy.parseError ? this.parseError = u.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;for (var _, m, d, k, b, x, v, w, $, E = function E() {\n                var t;return \"number\" != typeof (t = y.lex() || 1) && (t = e.symbols_[t] || t), t;\n            }, S = {};;) {\n                if (d = n[n.length - 1], this.defaultActions[d] ? k = this.defaultActions[d] : (null == _ && (_ = E()), k = r[d] && r[d][_]), void 0 === k || !k.length || !k[0]) {\n                    var I = \"\";for (x in $ = [], r[d]) {\n                        this.terminals_[x] && 2 < x && $.push(\"'\" + this.terminals_[x] + \"'\");\n                    }I = y.showPosition ? \"Parse error on line \" + (o + 1) + \":\\n\" + y.showPosition() + \"\\nExpecting \" + $.join(\", \") + \", got '\" + (this.terminals_[_] || _) + \"'\" : \"Parse error on line \" + (o + 1) + \": Unexpected \" + (1 == _ ? \"end of input\" : \"'\" + (this.terminals_[_] || _) + \"'\"), this.parseError(I, { text: y.match, token: this.terminals_[_] || _, line: y.yylineno, loc: f, expected: $ });\n                }if (k[0] instanceof Array && 1 < k.length) throw new Error(\"Parse Error: multiple actions possible at state: \" + d + \", token: \" + _);switch (k[0]) {case 1:\n                        n.push(_), s.push(y.yytext), i.push(y.yylloc), n.push(k[1]), _ = null, m ? (_ = m, m = null) : (a = y.yyleng, h = y.yytext, o = y.yylineno, f = y.yylloc, 0 < c && c--);break;case 2:\n                        if (v = this.productions_[k[1]][1], S.$ = s[s.length - v], S._$ = { first_line: i[i.length - (v || 1)].first_line, last_line: i[i.length - 1].last_line, first_column: i[i.length - (v || 1)].first_column, last_column: i[i.length - 1].last_column }, g && (S._$.range = [i[i.length - (v || 1)].range[0], i[i.length - 1].range[1]]), void 0 !== (b = this.performAction.apply(S, [h, a, o, u.yy, k[1], s, i].concat(l)))) return b;v && (n = n.slice(0, -1 * v * 2), s = s.slice(0, -1 * v), i = i.slice(0, -1 * v)), n.push(this.productions_[k[1]][0]), s.push(S.$), i.push(S._$), w = r[n[n.length - 2]][n[n.length - 1]], n.push(w);break;case 3:\n                        return !0;}\n            }return !0;\n        } };function m(t) {\n        var e = {};return t.forEach(function (t) {\n            if (t[0] in e) throw new Error(\"Duplicate key in record type.\");e[t[0]] = t[1];\n        }), e;\n    }var d = { EOF: 1, parseError: function parseError(t, e) {\n            if (!this.yy.parser) throw new Error(t);this.yy.parser.parseError(t, e);\n        }, setInput: function setInput(t, e) {\n            return this.yy = e || this.yy || {}, this._input = t, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = \"\", this.conditionStack = [\"INITIAL\"], this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;\n        }, input: function input() {\n            var t = this._input[0];return this.yytext += t, this.yyleng++, this.offset++, this.match += t, this.matched += t, t.match(/(?:\\r\\n?|\\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), t;\n        }, unput: function unput(t) {\n            var e = t.length,\n                n = t.split(/(?:\\r\\n?|\\n)/g);this._input = t + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - e), this.offset -= e;var s = this.match.split(/(?:\\r\\n?|\\n)/g);this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), n.length - 1 && (this.yylineno -= n.length - 1);var i = this.yylloc.range;return this.yylloc = { first_line: this.yylloc.first_line, last_line: this.yylineno + 1, first_column: this.yylloc.first_column, last_column: n ? (n.length === s.length ? this.yylloc.first_column : 0) + s[s.length - n.length].length - n[0].length : this.yylloc.first_column - e }, this.options.ranges && (this.yylloc.range = [i[0], i[0] + this.yyleng - e]), this.yyleng = this.yytext.length, this;\n        }, more: function more() {\n            return this._more = !0, this;\n        }, reject: function reject() {\n            return this.options.backtrack_lexer ? (this._backtrack = !0, this) : this.parseError(\"Lexical error on line \" + (this.yylineno + 1) + \". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n\" + this.showPosition(), { text: \"\", token: null, line: this.yylineno });\n        }, less: function less(t) {\n            this.unput(this.match.slice(t));\n        }, pastInput: function pastInput() {\n            var t = this.matched.substr(0, this.matched.length - this.match.length);return (20 < t.length ? \"...\" : \"\") + t.substr(-20).replace(/\\n/g, \"\");\n        }, upcomingInput: function upcomingInput() {\n            var t = this.match;return t.length < 20 && (t += this._input.substr(0, 20 - t.length)), (t.substr(0, 20) + (20 < t.length ? \"...\" : \"\")).replace(/\\n/g, \"\");\n        }, showPosition: function showPosition() {\n            var t = this.pastInput(),\n                e = new Array(t.length + 1).join(\"-\");return t + this.upcomingInput() + \"\\n\" + e + \"^\";\n        }, test_match: function test_match(t, e) {\n            var n, s, i;if (this.options.backtrack_lexer && (i = { yylineno: this.yylineno, yylloc: { first_line: this.yylloc.first_line, last_line: this.last_line, first_column: this.yylloc.first_column, last_column: this.yylloc.last_column }, yytext: this.yytext, match: this.match, matches: this.matches, matched: this.matched, yyleng: this.yyleng, offset: this.offset, _more: this._more, _input: this._input, yy: this.yy, conditionStack: this.conditionStack.slice(0), done: this.done }, this.options.ranges && (i.yylloc.range = this.yylloc.range.slice(0))), (s = t[0].match(/(?:\\r\\n?|\\n).*/g)) && (this.yylineno += s.length), this.yylloc = { first_line: this.yylloc.last_line, last_line: this.yylineno + 1, first_column: this.yylloc.last_column, last_column: s ? s[s.length - 1].length - s[s.length - 1].match(/\\r?\\n?/)[0].length : this.yylloc.last_column + t[0].length }, this.yytext += t[0], this.match += t[0], this.matches = t, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(t[0].length), this.matched += t[0], n = this.performAction.call(this, this.yy, this, e, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), n) return n;if (this._backtrack) {\n                for (var r in i) {\n                    this[r] = i[r];\n                }return !1;\n            }return !1;\n        }, next: function next() {\n            if (this.done) return this.EOF;var t, e, n, s;this._input || (this.done = !0), this._more || (this.yytext = \"\", this.match = \"\");for (var i = this._currentRules(), r = 0; r < i.length; r++) {\n                if ((n = this._input.match(this.rules[i[r]])) && (!e || n[0].length > e[0].length)) {\n                    if (e = n, s = r, this.options.backtrack_lexer) {\n                        if (!1 !== (t = this.test_match(n, i[r]))) return t;if (this._backtrack) {\n                            e = !1;continue;\n                        }return !1;\n                    }if (!this.options.flex) break;\n                }\n            }return e ? !1 !== (t = this.test_match(e, i[s])) && t : \"\" === this._input ? this.EOF : this.parseError(\"Lexical error on line \" + (this.yylineno + 1) + \". Unrecognized text.\\n\" + this.showPosition(), { text: \"\", token: null, line: this.yylineno });\n        }, lex: function lex() {\n            var t = this.next();return t || this.lex();\n        }, begin: function begin(t) {\n            this.conditionStack.push(t);\n        }, popState: function popState() {\n            return 0 < this.conditionStack.length - 1 ? this.conditionStack.pop() : this.conditionStack[0];\n        }, _currentRules: function _currentRules() {\n            return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;\n        }, topState: function topState(t) {\n            return 0 <= (t = this.conditionStack.length - 1 - Math.abs(t || 0)) ? this.conditionStack[t] : \"INITIAL\";\n        }, pushState: function pushState(t) {\n            this.begin(t);\n        }, stateStackSize: function stateStackSize() {\n            return this.conditionStack.length;\n        }, options: {}, performAction: function performAction(t, e, n, s) {\n            switch (n) {case 0:\n                    return 7;case 1:\n                    return 30;case 2:\n                    return 25;case 3:\n                    return 10;case 4:\n                    return 14;case 5:\n                    return 16;case 6:\n                    return 17;case 7:\n                    return 19;case 8:\n                    return 12;case 9:\n                    return 13;case 10:\n                    return 20;case 11:\n                    return 21;case 12:\n                    return 23;case 13:\n                    return 24;case 14:\n                    return 22;case 15:\n                    return \"'\";case 16:\n                    return 8;case 17:\n                    break;case 18:\n                    return 6;case 19:\n                    return \"INVALID\";}\n        }, rules: [/^(?:~>)/, /^(?:<=)/, /^(?:\\\\)/, /^(?:_\\b)/, /^(?:\\()/, /^(?:\\))/, /^(?:<)/, /^(?:>)/, /^(?:\\[)/, /^(?:\\])/, /^(?:\\{)/, /^(?:\\})/, /^(?:,)/, /^(?::)/, /^(?:\\+)/, /^(?:')/, /^(?:[_a-zA-Z][_a-zA-Z0-9]*)/, /^(?:\\s+)/, /^(?:$)/, /^(?:.)/], conditions: { INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19], inclusive: !0 } } };function k() {\n        this.yy = {};\n    }return _.lexer = d, new ((k.prototype = _).Parser = k)();\n}(); true && (exports.parser = parser, exports.Parser = parser.Parser, exports.parse = function () {\n    return parser.parse.apply(parser, arguments);\n}, exports.main = function (t) {\n    t[1] || (console.log(\"Usage: \" + t[0] + \" FILE\"), process.exit(1));var e = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())).readFileSync(__webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\").normalize(t[1]), \"utf8\");return exports.parser.parse(e);\n},  true && __webpack_require__.c[__webpack_require__.s] === module && exports.main(process.argv.slice(1)));\nvar numarrows = 0;\nvar numannotations = 0;\nvar annotationParseTime = 0;\n\nvar typechecks = 0;\nvar typecheckTime = 0;\n\nvar started = void 0;\nvar typecheck = true;\nvar benchmark = false;\nvar displaychecks = false;\n\nfunction _benchmarkStart(shouldTypecheck) {\n    benchmark = true;\n    typecheck = shouldTypecheck;\n\n    started = window.performance.now();\n}\n\nfunction _benchmarkResultsOrRun() /* ...arrows */{\n    if (benchmark) {\n        var elapsed = window.performance.now() - started;\n\n        console.log(\"Arrows: \" + numarrows);\n        console.log(\"Num annotations: \" + numannotations);\n        console.log(\"Composition time: \" + elapsed + \" (\" + annotationParseTime + \")\");\n    } else {\n        for (var i = 0; i < arguments.length; i++) {\n            arguments[i].run();\n        }\n    }\n}\n\nfunction _construct(f) {\n    if (typecheck) {\n        return f();\n    } else {\n        return new ArrowType(new TopType(), new TopType());\n    }\n}\n\nfunction _check(type, value) {\n    if (typecheck) {\n        var start = window.performance.now();\n\n        type.check(value);\n\n        var elapsed = window.performance.now() - start;\n        typechecks++;\n        typecheckTime += elapsed;\n\n        if (displaychecks) {\n            console.log(typechecks + \" checks, \" + typecheckTime + \"ms\");\n        }\n    }\n}\n\nArray.create = function (length, value) {\n    var arr = [];\n    while (--length >= 0) {\n        arr.push(value);\n    }\n\n    return arr;\n};\n\nArray.copy = function (array) {\n    return [].slice.call(array);\n};\n\nArray.prototype.unique = function () {\n    return this.filter(function (v, i, s) {\n        return s.indexOf(v) === i;\n    });\n};\n\nFunction.prototype.lift = function () {\n    return new LiftedArrow(this);\n};\n\nNumber.prototype.lift = function () {\n    var value = this.valueOf();\n\n    return new LiftedArrow(function () {\n        /* @arrow :: _ ~> Number */\n        return value;\n    });\n};\n\nBoolean.prototype.lift = function () {\n    var value = this.valueOf();\n\n    return new LiftedArrow(function () {\n        /* @arrow : _ ~> Bool */\n        return value;\n    });\n};\n\nvar Arrow = function () {\n    function Arrow(type) {\n        _classCallCheck(this, Arrow);\n\n        numarrows++;\n        this.type = type;\n    }\n\n    _createClass(Arrow, [{\n        key: \"call\",\n        value: function call(x, p, k, h) {\n            throw new Error(\"Call undefined\");\n        }\n    }, {\n        key: \"equals\",\n        value: function equals(that) {\n            throw new Error(\"Equals undefined\");\n        }\n    }, {\n        key: \"isAsync\",\n        value: function isAsync() {\n            return false;\n        }\n    }, {\n        key: \"run\",\n        value: function run() {\n            if (!(this.type.arg instanceof TopType)) {\n                throw new Error(\"Cannot run an arrow that takes arguments\");\n            }\n\n            var p = new Progress(true);\n            this.call(null, p, function () {}, function (err) {\n                throw err;\n            });\n            return p;\n        }\n\n        // Combinator constructors\n\n    }, {\n        key: \"noemit\",\n        value: function noemit() {\n            return Arrow.noemit(this);\n        }\n    }, {\n        key: \"seq\",\n        value: function seq() /* ...arrows */{\n            return Arrow.seq([this].concat(Array.copy(arguments)));\n        }\n    }, {\n        key: \"any\",\n        value: function any() /* ...arrows */{\n            return Arrow.any([this].concat(Array.copy(arguments)));\n        }\n    }, {\n        key: \"all\",\n        value: function all() /* ...arrows */{\n            return Arrow.all([this].concat(Array.copy(arguments)));\n        }\n    }, {\n        key: \"try\",\n        value: function _try(success, failure) {\n            return Arrow.try(this, success, failure);\n        }\n\n        // Convenience API\n\n    }, {\n        key: \"named\",\n        value: function named(name) {\n            return new NamedArrow(name, this);\n        }\n    }, {\n        key: \"lift\",\n        value: function lift() {\n            return this;\n        }\n    }, {\n        key: \"wait\",\n        value: function wait(duration) {\n            return this.seq(new DelayArrow(duration));\n        }\n    }, {\n        key: \"after\",\n        value: function after(duration) {\n            return new DelayArrow(duration).seq(this);\n        }\n    }, {\n        key: \"triggeredBy\",\n        value: function triggeredBy(selector, event) {\n            return new ElemArrow(selector).seq(new EventArrow(event)).remember().seq(this);\n        }\n    }, {\n        key: \"then\",\n        value: function then(success, failure) {\n            if (failure === undefined) {\n                return this.seq(success);\n            } else {\n                return this.try(success, failure);\n            }\n        }\n    }, {\n        key: \"catch\",\n        value: function _catch(failure) {\n            return this.then(Arrow.id(), failure);\n        }\n\n        // Data Routing\n\n    }, {\n        key: \"split\",\n        value: function split(n) {\n            return this.seq(new SplitArrow(n));\n        }\n    }, {\n        key: \"nth\",\n        value: function nth(n) {\n            return this.seq(new NthArrow(n));\n        }\n    }, {\n        key: \"fanout\",\n        value: function fanout() /* ...arrows */{\n            return Arrow.fanout([this].concat(Array.copy(arguments)));\n        }\n    }, {\n        key: \"tap\",\n        value: function tap() /* ...functions */{\n            var sec = getNonNullElems(Array.copy(arguments)).map(function (a) {\n                return a.lift();\n            });\n            var all = [this].concat(sec);\n            var rem = [this].concat(sec.map(function (a) {\n                return a.remember();\n            }));\n\n            return new NamedArrow(\"tap(\" + all.map(function (a) {\n                return a.toString();\n            }).join(\", \") + \")\", Arrow.seq(rem));\n        }\n    }, {\n        key: \"on\",\n        value: function on(name, handler) {\n            return new NamedArrow(\"on(\" + name + \", {0})\", this.seq(new SplitArrow(2), Arrow.id().all(new EventArrow(name)), handler), [handler]);\n        }\n    }, {\n        key: \"remember\",\n        value: function remember() {\n            return new NamedArrow(\"remember({0})\", this.carry().nth(1), [this]);\n        }\n    }, {\n        key: \"carry\",\n        value: function carry() {\n            return new NamedArrow(\"carry({0})\", new SplitArrow(2).seq(Arrow.id().all(this)), [this]);\n        }\n\n        // Repeating\n\n    }, {\n        key: \"repeat\",\n        value: function repeat() {\n            var _this = this;\n\n            return new NamedArrow(\"repeat({0})\", Arrow.fix(function (a) {\n                return _this.wait(0).seq(Arrow.try(Arrow.repeatTail(), a, Arrow.id()));\n            }), [this]);\n        }\n    }, {\n        key: \"times\",\n        value: function times(n) {\n            var init = new LiftedArrow(function () {\n                /* @arrow :: _ ~> Number */\n                return n;\n            });\n\n            var rep = new LiftedArrow(function (n, x, y) {\n                /* @arrow :: (Number, 'a, 'b) ~> <loop: (Number, 'a, 'a), halt: 'b> */\n                return n > 1 ? Arrow.loop([n - 1, x, x]) : Arrow.halt(y);\n            });\n\n            var arr = Arrow.seq([Arrow.fanout([init.lift(), Arrow.id(), Arrow.id()]), Arrow.all([Arrow.id(), Arrow.id(), this]).seq(rep).repeat()]);\n\n            return new NamedArrow(\"times(\" + n + \", {0})\", arr, [this]);\n        }\n    }, {\n        key: \"forever\",\n        value: function forever() {\n            return new NamedArrow(\"forever({0})\", this.seq(Arrow.reptop()).repeat(), [this]);\n        }\n    }, {\n        key: \"whileTrue\",\n        value: function whileTrue() {\n            return new NamedArrow(\"whileTrue({0})\", this.carry().seq(Arrow.repcond()).repeat(), [this]);\n        }\n    }]);\n\n    return Arrow;\n}();\n\n// Unary combinators\n\n\nArrow.noemit = function (arrow) {\n    return new NoEmitCombinator(arrow);\n};\n\n// N-ary combinators\nArrow.seq = function (arrows) {\n    return new SeqCombinator(arrows);\n};\nArrow.any = function (arrows) {\n    return new AnyCombinator(arrows);\n};\nArrow.all = function (arrows) {\n    return new AllCombinator(arrows);\n};\nArrow.try = function (a, s, f) {\n    return new TryCombinator(a, s, f);\n};\nArrow.fanout = function (arrows) {\n    arrows = getNonNullArrows(arrows);\n    var result = new SplitArrow(arrows.length).seq(Arrow.all(arrows));\n    return new NamedArrow(\"fanout(\" + arrows.map(function (a) {\n        return a.toString();\n    }).join(\", \") + \")\", result, arrows);\n};\n\n// Convenience\nArrow.repeat = function (a) {\n    return a.repeat();\n};\nArrow.bind = function (event, a) {\n    return new NamedArrow(\"bind(\" + event + \", {0})\", Arrow.seq([new SplitArrow(2), Arrow.id().all(new EventArrow(event)), a]), [a]);\n};\nArrow.catch = function (a, f) {\n    return Arrow.try(a, Arrow.id(), f);\n};\nArrow.db = function (f, db) {\n    return new QueryArrow(f, db);\n};\n\n// Built-ins\nArrow.id = function () {\n    return new LiftedArrow(function (x) {\n        /* @arrow :: 'a ~> 'a */\n        return x;\n    }).named(\"id\");\n};\n\nArrow.log = function () {\n    return new LiftedArrow(function (x) {\n        /* @arrow :: 'a ~> 'a */\n        console.log(x);\n        return x;\n    }).named(\"log\");\n};\n\nArrow.throwFalse = function () {\n    return new LiftedArrow(function (x) {\n        /* @arrow :: Bool ~> _ \\ ({}, {Bool}) */\n        if (x) {\n            throw x;\n        }\n    }).named(\"throwFalse\");\n};\n\n// Repetition helpers\nArrow.reptop = function () {\n    return new LiftedArrow(function (x) {\n        /* @arrow :: _ ~> <loop: _, halt: _> */\n        return Arrow.loop(null);\n    });\n};\n\nArrow.repcond = function () {\n    return new LiftedArrow(function (x, f) {\n        /* @arrow :: ('a, Bool) ~> <loop: 'a, halt: _> */\n        return f ? Arrow.loop(x) : Arrow.halt(null);\n    });\n};\n\nArrow.repeatTail = function () {\n    return new LiftedArrow(function (x) {\n        /* @arrow :: <loop: 'a, halt: 'b> ~> 'a \\ ({}, {'b}) */\n        if (x.hasTag(\"loop\")) {\n            return x.value();\n        } else {\n            throw x.value();\n        }\n    });\n};\n\nvar TaggedValue = function () {\n    function TaggedValue(tag, val) {\n        _classCallCheck(this, TaggedValue);\n\n        this.tag = tag;\n        this.val = val;\n    }\n\n    _createClass(TaggedValue, [{\n        key: \"hasTag\",\n        value: function hasTag(tag) {\n            return tag == this.tag;\n        }\n    }, {\n        key: \"value\",\n        value: function value() {\n            return this.val;\n        }\n    }]);\n\n    return TaggedValue;\n}();\n\n// Utility Constructors\n\n\nArrow.loop = function (x) {\n    return new TaggedValue(\"loop\", x);\n};\nArrow.halt = function (x) {\n    return new TaggedValue(\"halt\", x);\n};\n\nvar _cancelerId = 0;\n\nvar Progress = function () {\n    function Progress(canEmit) {\n        _classCallCheck(this, Progress);\n\n        this.canEmit = canEmit;\n        this.cancelers = {};\n        this.observers = [];\n    }\n\n    _createClass(Progress, [{\n        key: \"addObserver\",\n        value: function addObserver(observer) {\n            this.observers.push(observer);\n        }\n    }, {\n        key: \"addCanceler\",\n        value: function addCanceler(canceler) {\n            var id = _cancelerId++;\n            this.cancelers[id] = canceler;\n            return id;\n        }\n    }, {\n        key: \"advance\",\n        value: function advance(cancelerId) {\n            if (cancelerId != null) {\n                this.cancelers[cancelerId] = null;\n            }\n\n            while (this.observers.length > 0) {\n                var observer = this.observers.pop();\n\n                if (this.canEmit) {\n                    observer();\n                }\n            }\n        }\n    }, {\n        key: \"cancel\",\n        value: function cancel() {\n            for (var id in this.cancelers) {\n                if (this.cancelers[id] != null) {\n                    this.cancelers[id]();\n                }\n            }\n\n            this.cancelers = {};\n        }\n    }]);\n\n    return Progress;\n}();\n\nvar annotationCache = {};\n\nvar LiftedArrow = function (_Arrow) {\n    _inherits(LiftedArrow, _Arrow);\n\n    function LiftedArrow(f) {\n        _classCallCheck(this, LiftedArrow);\n\n        if (!(f instanceof Function)) {\n            throw new Error(\"Cannot lift non-function\");\n        }\n\n        var _this2 = _possibleConstructorReturn(this, (LiftedArrow.__proto__ || Object.getPrototypeOf(LiftedArrow)).call(this, _construct(function () {\n            var start = window.performance.now();\n\n            var s = f.toString();\n            var i = s.indexOf(\"/*\");\n            var j = s.indexOf(\"*/\", i + 1);\n            var c = s.substring(i + 2, j);\n\n            var parsed = annotationCache[c];\n\n            if (annotationCache[c] === undefined) {\n                var comment = void 0;\n\n                try {\n                    comment = c.match(/\\@arrow :: (.*)\\n?/)[1];\n                } catch (err) {\n                    if (typecheck) {\n                        console.warn(\"Function being lifted does not contain an @arrow annotation\");\n                    }\n\n                    comment = \"_ ~> _\";\n                }\n\n                try {\n                    // jison exports the parser name like this\n                    parsed = parser.parse(comment);\n                } catch (err) {\n                    throw new ComposeError(\"Function being lifted does not contain a parseable @arrow annotation.\\n\" + err.message + \"\\n\");\n                }\n\n                annotationCache[c] = parsed;\n            }\n\n            var elapsed = window.performance.now() - start;\n            numannotations++;\n            annotationParseTime += elapsed;\n\n            var arg = parsed[0];\n            var out = parsed[1];\n            var ncs = new ConstraintSet([]).addAll(parsed[2][0]);\n\n            return new ArrowType(arg, out, ncs, parsed[2][1]).sanitize();\n        })));\n\n        _this2.f = f;\n        return _this2;\n    }\n\n    _createClass(LiftedArrow, [{\n        key: \"toString\",\n        value: function toString() {\n            return \"lift :: \" + this.type.toString();\n        }\n    }, {\n        key: \"call\",\n        value: function call(x, p, k, h) {\n            var result = void 0;\n\n            try {\n                // If the function has more than one parameter and we have\n                // an array argument, spread the elements. Else, just call\n                // the function with a single argument.\n\n                if (x && x.constructor === Array && this.f.length > 1) {\n                    result = this.f.apply(null, x);\n                } else {\n                    result = this.f(x);\n                }\n\n                _check(this.type.out, result);\n            } catch (err) {\n                return h(err);\n            }\n\n            k(result);\n        }\n    }, {\n        key: \"equals\",\n        value: function equals(that) {\n            return that instanceof LiftedArrow && this.f === that.f;\n        }\n    }]);\n\n    return LiftedArrow;\n}(Arrow);\n\nvar ElemArrow = function (_LiftedArrow) {\n    _inherits(ElemArrow, _LiftedArrow);\n\n    function ElemArrow(selector) {\n        _classCallCheck(this, ElemArrow);\n\n        var _this3 = _possibleConstructorReturn(this, (ElemArrow.__proto__ || Object.getPrototypeOf(ElemArrow)).call(this, function () {\n            /* @arrow :: _ ~> Elem */\n            return $(selector);\n        }));\n\n        _this3.selector = selector;\n        return _this3;\n    }\n\n    _createClass(ElemArrow, [{\n        key: \"toString\",\n        value: function toString() {\n            return \"elem :: \" + this.type.toString();\n        }\n    }, {\n        key: \"equals\",\n        value: function equals(that) {\n            return that instanceof ElemArrow && this.selector === that.selector;\n        }\n    }]);\n\n    return ElemArrow;\n}(LiftedArrow);\n\n//\n// Simple Asynchronous Arrow Implementation\n//\n\nvar SimpleAsyncArrow = function (_Arrow2) {\n    _inherits(SimpleAsyncArrow, _Arrow2);\n\n    function SimpleAsyncArrow() {\n        _classCallCheck(this, SimpleAsyncArrow);\n\n        return _possibleConstructorReturn(this, (SimpleAsyncArrow.__proto__ || Object.getPrototypeOf(SimpleAsyncArrow)).apply(this, arguments));\n    }\n\n    _createClass(SimpleAsyncArrow, [{\n        key: \"isAsync\",\n        value: function isAsync() {\n            return true;\n        }\n    }]);\n\n    return SimpleAsyncArrow;\n}(Arrow);\n\n// Simple Asynchronous Arrow that takes in a config object\n\nvar SimpleConfigBasedAsyncArrow = function (_SimpleAsyncArrow) {\n    _inherits(SimpleConfigBasedAsyncArrow, _SimpleAsyncArrow);\n\n    function SimpleConfigBasedAsyncArrow(f, errorType) {\n        _classCallCheck(this, SimpleConfigBasedAsyncArrow);\n\n        if (!(f instanceof Function)) {\n            throw new Error(\"Cannot use non-function as configuration value\");\n        }\n\n        var _this5 = _possibleConstructorReturn(this, (SimpleConfigBasedAsyncArrow.__proto__ || Object.getPrototypeOf(SimpleConfigBasedAsyncArrow)).call(this, _construct(function () {\n            var start = window.performance.now();\n\n            var s = f.toString();\n            var i = s.indexOf(\"/*\");\n            var j = s.indexOf(\"*/\", i + 1);\n            var c = s.substring(i + 2, j);\n\n            var ncs = new ConstraintSet([]);\n            var err = [new NamedType(errorType)];\n\n            var conf = void 0;\n            var resp = void 0;\n\n            if (annotationCache[c] !== undefined) {\n                conf = annotationCache[c][0];\n                resp = annotationCache[c][1];\n            } else {\n                try {\n                    // jison exports the parser name like this\n                    conf = parser.parse(c.match(/\\@conf :: (.*)\\n?/)[1]);\n\n                    ncs = ncs.addAll(conf[1][0]);\n                    err = err.concat(conf[1][1]);\n                } catch (err) {\n                    throw new ComposeError(\"Config does not contain a parseable @conf annotation.\\n\" + err.message + \"\\n\");\n                }\n\n                try {\n                    // jison exports the parser name like this\n                    resp = parser.parse(c.match(/\\@resp :: (.*)\\n?/)[1]);\n\n                    ncs = ncs.addAll(resp[1][0]);\n                    err = err.concat(resp[1][1]);\n                } catch (err) {\n                    throw new ComposeError(\"Config does not contain a parseable @resp annotation.\\n\" + err.message + \"\\n\");\n                }\n\n                annotationCache[c] = [conf, resp];\n            }\n\n            var elapsed = window.performance.now() - start;\n            numannotations++;\n            annotationParseTime += elapsed;\n\n            return new ArrowType(conf[0], resp[0], ncs, err).sanitize();\n        })));\n\n        _this5.c = f;\n        return _this5;\n    }\n\n    return SimpleConfigBasedAsyncArrow;\n}(SimpleAsyncArrow);\n\nvar AjaxArrow = function (_SimpleConfigBasedAsy) {\n    _inherits(AjaxArrow, _SimpleConfigBasedAsy);\n\n    function AjaxArrow(f) {\n        _classCallCheck(this, AjaxArrow);\n\n        return _possibleConstructorReturn(this, (AjaxArrow.__proto__ || Object.getPrototypeOf(AjaxArrow)).call(this, f, \"AjaxError\"));\n    }\n\n    _createClass(AjaxArrow, [{\n        key: \"toString\",\n        value: function toString() {\n            return \"ajax :: \" + this.type.toString();\n        }\n    }, {\n        key: \"call\",\n        value: function call(x, p, k, h) {\n            var _this7 = this;\n\n            // If the function has more than one parameter and we have\n            // an array argument, spread the elements. Else, just call\n            // the function with a single argument.\n\n            // TODO - wrap this in try\n\n            var conf = void 0;\n            if (x && x.constructor === Array && this.c.length > 1) {\n                conf = this.c.apply(null, x);\n            } else {\n                conf = this.c(x);\n            }\n\n            var abort = false;\n\n            var cancel = function cancel() {\n                abort = true;\n            };\n\n            var fail = h;\n            var succ = function succ(x) {\n                _check(_this7.type.out, x);\n                k(x);\n            };\n\n            $.ajax($.extend(conf, {\n                success: function success(x, status, xhr) {\n                    if (!abort) {\n                        p.advance(cancelerId);succ(x);\n                    }\n                },\n                error: function error(xhr, status, x) {\n                    if (!abort) {\n                        p.advance(cancelerId);fail(x);\n                    }\n                }\n            }));\n\n            var cancelerId = p.addCanceler(cancel);\n        }\n    }, {\n        key: \"equals\",\n        value: function equals(that) {\n            // TODO - deep comparison of objects\n            return that instanceof AjaxArrow && this.c === that.c;\n        }\n    }]);\n\n    return AjaxArrow;\n}(SimpleConfigBasedAsyncArrow);\n\nvar QueryArrow = function (_SimpleConfigBasedAsy2) {\n    _inherits(QueryArrow, _SimpleConfigBasedAsy2);\n\n    function QueryArrow(f, db) {\n        _classCallCheck(this, QueryArrow);\n\n        var _this8 = _possibleConstructorReturn(this, (QueryArrow.__proto__ || Object.getPrototypeOf(QueryArrow)).call(this, f, \"QueryError\"));\n\n        _this8.db = db;\n        return _this8;\n    }\n\n    _createClass(QueryArrow, [{\n        key: \"toString\",\n        value: function toString() {\n            return \"query :: \" + this.type.toString();\n        }\n    }, {\n        key: \"call\",\n        value: function call(x, p, k, h) {\n            var _this9 = this;\n\n            var conf = void 0;\n            if (x && x.constructor === Array && this.c.length > 1) {\n                conf = this.c.apply(null, x);\n            } else {\n                conf = this.c(x);\n            }\n\n            var abort = false;\n\n            var cancel = function cancel() {\n                abort = true;\n            };\n\n            var fail = h;\n            var succ = function succ(x) {\n                _check(_this9.type.out, x);\n                k(x);\n            };\n\n            this.db.query(conf.query, conf.param, function (err, rows) {\n                if (err) {\n                    if (!abort) {\n                        p.advance(cancelerId);\n                        fail(err);\n                    }\n                } else {\n                    if (!abort) {\n                        p.advance(cancelerId);\n                        succ(rows);\n                    }\n                }\n            });\n\n            var cancelerId = p.addCanceler(cancel);\n        }\n    }, {\n        key: \"equals\",\n        value: function equals(that) {\n            // TODO - deep comparison of objects\n            return that instanceof QueryArrow && this.c === that.c;\n        }\n    }]);\n\n    return QueryArrow;\n}(SimpleConfigBasedAsyncArrow);\n\nvar EventArrow = function (_SimpleAsyncArrow2) {\n    _inherits(EventArrow, _SimpleAsyncArrow2);\n\n    function EventArrow(name) {\n        _classCallCheck(this, EventArrow);\n\n        var _this10 = _possibleConstructorReturn(this, (EventArrow.__proto__ || Object.getPrototypeOf(EventArrow)).call(this, _construct(function () {\n            return new ArrowType(new NamedType(\"Elem\"), new NamedType(\"Event\"));\n        })));\n        // Elem ~> Event\n\n\n        _this10.name = name;\n        return _this10;\n    }\n\n    _createClass(EventArrow, [{\n        key: \"toString\",\n        value: function toString() {\n            return \"event(\" + this.name + \") :: \" + this.type.toString();\n        }\n    }, {\n        key: \"call\",\n        value: function call(x, p, k, h) {\n            var _this11 = this;\n\n            var abort = false;\n\n            var cancel = function cancel() {\n                abort = true;\n                x.off(_this11.name, runner);\n            };\n\n            var runner = function runner(ev) {\n                if (!abort) {\n                    cancel();\n                    p.advance(cancelerId);\n                    k(ev);\n                }\n            };\n\n            x.on(this.name, runner);\n            var cancelerId = p.addCanceler(cancel);\n        }\n    }, {\n        key: \"equals\",\n        value: function equals(that) {\n            return that instanceof EventArrow && this.name === that.name;\n        }\n    }]);\n\n    return EventArrow;\n}(SimpleAsyncArrow);\n\nvar DynamicDelayArrow = function (_SimpleAsyncArrow3) {\n    _inherits(DynamicDelayArrow, _SimpleAsyncArrow3);\n\n    function DynamicDelayArrow() {\n        _classCallCheck(this, DynamicDelayArrow);\n\n        // Number ~> _\n        return _possibleConstructorReturn(this, (DynamicDelayArrow.__proto__ || Object.getPrototypeOf(DynamicDelayArrow)).call(this, _construct(function () {\n            return new ArrowType(new NamedType(\"Number\"), new TopType());\n        })));\n    }\n\n    _createClass(DynamicDelayArrow, [{\n        key: \"toString\",\n        value: function toString() {\n            return \"delay :: \" + this.type.toString();\n        }\n    }, {\n        key: \"call\",\n        value: function call(x, p, k, h) {\n            var cancel = function cancel() {\n                return clearTimeout(timer);\n            };\n            var runner = function runner() {\n                p.advance(cancelerId);\n                k();\n            };\n\n            var timer = setTimeout(runner, x);\n            var cancelerId = p.addCanceler(cancel);\n        }\n    }, {\n        key: \"equals\",\n        value: function equals(that) {\n            return that instanceof DynamicDelayArrow;\n        }\n    }]);\n\n    return DynamicDelayArrow;\n}(SimpleAsyncArrow);\n\nvar DelayArrow = function (_SimpleAsyncArrow4) {\n    _inherits(DelayArrow, _SimpleAsyncArrow4);\n\n    function DelayArrow(duration) {\n        _classCallCheck(this, DelayArrow);\n\n        var _this13 = _possibleConstructorReturn(this, (DelayArrow.__proto__ || Object.getPrototypeOf(DelayArrow)).call(this, _construct(function () {\n            var alpha = ParamType.fresh();\n            return new ArrowType(alpha, alpha);\n        })));\n        // \"a ~> \"a\n\n\n        _this13.duration = duration;\n        return _this13;\n    }\n\n    _createClass(DelayArrow, [{\n        key: \"toString\",\n        value: function toString() {\n            return \"delay(\" + this.duration + \") :: \" + this.type.toString();\n        }\n    }, {\n        key: \"call\",\n        value: function call(x, p, k, h) {\n            var cancel = function cancel() {\n                return clearTimeout(timer);\n            };\n            var runner = function runner() {\n                p.advance(cancelerId);\n                k(x);\n            };\n\n            var timer = setTimeout(runner, this.duration);\n            var cancelerId = p.addCanceler(cancel);\n        }\n    }, {\n        key: \"equals\",\n        value: function equals(that) {\n            return that instanceof Delay && this.duration === that.duration;\n        }\n    }]);\n\n    return DelayArrow;\n}(SimpleAsyncArrow);\n\n//\n// Simple (Generalized) Arrows\n//\n\nvar SplitArrow = function (_Arrow3) {\n    _inherits(SplitArrow, _Arrow3);\n\n    function SplitArrow(n) {\n        _classCallCheck(this, SplitArrow);\n\n        var _this14 = _possibleConstructorReturn(this, (SplitArrow.__proto__ || Object.getPrototypeOf(SplitArrow)).call(this, _construct(function () {\n            var arg = ParamType.fresh();\n            var out = Array.create(n, arg);\n\n            return new ArrowType(arg, new TupleType(out));\n        })));\n\n        _this14.n = n;\n        return _this14;\n    }\n\n    _createClass(SplitArrow, [{\n        key: \"toString\",\n        value: function toString() {\n            return \"split(\" + this.n + \") :: \" + this.type.toString();\n        }\n    }, {\n        key: \"call\",\n        value: function call(x, p, k, h) {\n            // TODO - clone values\n            k(Array.create(this.n, x));\n        }\n    }, {\n        key: \"equals\",\n        value: function equals(that) {\n            return that instanceof SplitArrow && this.n === that.n;\n        }\n    }]);\n\n    return SplitArrow;\n}(Arrow);\n\nvar NthArrow = function (_Arrow4) {\n    _inherits(NthArrow, _Arrow4);\n\n    function NthArrow(n) {\n        _classCallCheck(this, NthArrow);\n\n        var _this15 = _possibleConstructorReturn(this, (NthArrow.__proto__ || Object.getPrototypeOf(NthArrow)).call(this, _construct(function () {\n            var arg = Array.create(n).map(function () {\n                return ParamType.fresh();\n            });\n            var out = arg[n - 1];\n\n            return new ArrowType(new TupleType(arg), out);\n        })));\n\n        _this15.n = n;\n        return _this15;\n    }\n\n    _createClass(NthArrow, [{\n        key: \"toString\",\n        value: function toString() {\n            return \"nth(\" + this.n + \") :: \" + this.type.toString();\n        }\n    }, {\n        key: \"call\",\n        value: function call(x, p, k, h) {\n            k(x[this.n - 1]);\n        }\n    }, {\n        key: \"equals\",\n        value: function equals(that) {\n            return that instanceof NthArrow && this.n === that.n;\n        }\n    }]);\n\n    return NthArrow;\n}(Arrow);\n\nvar ComposeError = function (_Error) {\n    _inherits(ComposeError, _Error);\n\n    function ComposeError(message) {\n        _classCallCheck(this, ComposeError);\n\n        var _this16 = _possibleConstructorReturn(this, (ComposeError.__proto__ || Object.getPrototypeOf(ComposeError)).call(this));\n\n        _this16.message = message;\n        return _this16;\n    }\n\n    _createClass(ComposeError, [{\n        key: \"toString\",\n        value: function toString() {\n            return this.message;\n        }\n    }]);\n\n    return ComposeError;\n}(Error);\n\nvar Combinator = function (_Arrow5) {\n    _inherits(Combinator, _Arrow5);\n\n    function Combinator(type, arrows) {\n        _classCallCheck(this, Combinator);\n\n        var _this17 = _possibleConstructorReturn(this, (Combinator.__proto__ || Object.getPrototypeOf(Combinator)).call(this, type));\n\n        _this17.arrows = arrows;\n        return _this17;\n    }\n\n    _createClass(Combinator, [{\n        key: \"toString\",\n        value: function toString() {\n            return this.constructor.name + \"(\" + this.arrows.map(function (a) {\n                return a.toString();\n            }).join(\", \") + \") :: \" + this.type.toString();\n        }\n    }, {\n        key: \"isAsync\",\n        value: function isAsync() {\n            return this.arrows.some(function (a) {\n                return a.isAsync();\n            });\n        }\n    }, {\n        key: \"equals\",\n        value: function equals(that) {\n            if (this.constructor === that.constructor) {\n                return this.arrows.length === that.arrows.length && this.arrows.every(function (a, i) {\n                    return a.equals(that.arrows[i]);\n                });\n            }\n\n            return false;\n        }\n    }]);\n\n    return Combinator;\n}(Arrow);\n\nvar NamedArrow = function (_Combinator) {\n    _inherits(NamedArrow, _Combinator);\n\n    function NamedArrow(name, a, args) {\n        _classCallCheck(this, NamedArrow);\n\n        ensureArrow(a);\n\n        var _this18 = _possibleConstructorReturn(this, (NamedArrow.__proto__ || Object.getPrototypeOf(NamedArrow)).call(this, _construct(function () {\n            return a.type;\n        }), [a]));\n\n        _this18.name = format(name, (args || []).map(function (a) {\n            return a.toString();\n        }));\n        return _this18;\n    }\n\n    _createClass(NamedArrow, [{\n        key: \"toString\",\n        value: function toString() {\n            return this.name + \" :: \" + this.arrows[0].type.toString();\n        }\n    }, {\n        key: \"call\",\n        value: function call(x, p, k, h) {\n            this.arrows[0].call(x, p, k, h);\n        }\n    }, {\n        key: \"isAsync\",\n        value: function isAsync() {\n            return this.arrows[0].isAsync();\n        }\n    }]);\n\n    return NamedArrow;\n}(Combinator);\n\nvar NoEmitCombinator = function (_Combinator2) {\n    _inherits(NoEmitCombinator, _Combinator2);\n\n    function NoEmitCombinator(a) {\n        _classCallCheck(this, NoEmitCombinator);\n\n        ensureArrow(a);\n\n        return _possibleConstructorReturn(this, (NoEmitCombinator.__proto__ || Object.getPrototypeOf(NoEmitCombinator)).call(this, _construct(function () {\n            return a.type;\n        }), [a]));\n    }\n\n    _createClass(NoEmitCombinator, [{\n        key: \"toString\",\n        value: function toString() {\n            return \"noemit(\" + this.arrows[0].toString() + \") :: \" + this.type.toString();\n        }\n    }, {\n        key: \"call\",\n        value: function call(x, p, k, h) {\n            var quiet = new Progress(false);\n            p.addCanceler(function () {\n                return quiet.cancel();\n            });\n\n            this.arrows[0].call(x, quiet, function (z) {\n                p.advance();\n\n                setTimeout(function () {\n                    k(z);\n                }, 0);\n            }, h);\n        }\n    }, {\n        key: \"isAsync\",\n        value: function isAsync() {\n            return true;\n        }\n    }]);\n\n    return NoEmitCombinator;\n}(Combinator);\n\nvar SeqCombinator = function (_Combinator3) {\n    _inherits(SeqCombinator, _Combinator3);\n\n    function SeqCombinator(arrows) {\n        _classCallCheck(this, SeqCombinator);\n\n        arrows = getNonNullArrows(arrows);\n\n        return _possibleConstructorReturn(this, (SeqCombinator.__proto__ || Object.getPrototypeOf(SeqCombinator)).call(this, _construct(function () {\n            var sty = sanitizeTypes(arrows);\n\n            try {\n                var len = sty.length - 1;\n\n                var arg = sty[0].arg;\n                var out = sty[len].out;\n                var ncs = new ConstraintSet([]);\n                var err = sty[0].errors;\n\n                sty.forEach(function (t, i) {\n                    ncs = ncs.concat(t.constraints);\n                    err = err.concat(t.errors);\n\n                    if (i != 0) {\n                        ncs = ncs.add(new Constraint(sty[i - 1].out, t.arg));\n                    }\n                });\n\n                return new ArrowType(arg, out, ncs, err);\n            } catch (err) {\n                var message = void 0;\n                var location = getLocation(err.stack);\n\n                if (location) {\n                    message = \"Unable to seq arrows at: \" + location;\n                } else {\n                    message = \"Unable to seq arrows\";\n                }\n\n                throw new ComposeError(message + \"\\n\\tInput => Seq(\" + sty.join(\", \") + \")\\n\\tError => \" + err);\n            }\n        }), arrows));\n    }\n\n    _createClass(SeqCombinator, [{\n        key: \"toString\",\n        value: function toString() {\n            return \"seq(\" + this.arrows.map(function (a) {\n                return a.toString();\n            }).join(\", \") + \") :: \" + this.type.toString();\n        }\n    }, {\n        key: \"call\",\n        value: function call(x, p, k, h) {\n            var rec = function rec(y, _ref) {\n                var _ref2 = _toArray(_ref),\n                    head = _ref2[0],\n                    tail = _ref2.slice(1);\n\n                if (head === undefined) {\n                    k(y);\n                } else {\n                    head.call(y, p, function (z) {\n                        return rec(z, tail);\n                    }, h);\n                }\n            };\n\n            rec(x, this.arrows);\n        }\n    }]);\n\n    return SeqCombinator;\n}(Combinator);\n\nvar AllCombinator = function (_Combinator4) {\n    _inherits(AllCombinator, _Combinator4);\n\n    function AllCombinator(arrows) {\n        _classCallCheck(this, AllCombinator);\n\n        arrows = getNonNullArrows(arrows);\n\n        return _possibleConstructorReturn(this, (AllCombinator.__proto__ || Object.getPrototypeOf(AllCombinator)).call(this, _construct(function () {\n            var sty = sanitizeTypes(arrows);\n\n            try {\n                var arg = [];\n                var out = [];\n                var ncs = new ConstraintSet([]);\n                var err = [];\n\n                sty.forEach(function (t, i) {\n                    arg.push(t.arg);\n                    out.push(t.out);\n\n                    ncs = ncs.concat(t.constraints);\n                    err = err.concat(t.errors);\n                });\n\n                return new ArrowType(new TupleType(arg), new TupleType(out), ncs, err);\n            } catch (err) {\n                var message = void 0;\n                var location = getLocation(err.stack);\n\n                if (location) {\n                    message = \"Unable to all arrows at: \" + location;\n                } else {\n                    message = \"Unable to all arrows\";\n                }\n\n                throw new ComposeError(message + \"\\n\\tInput => All(\" + sty.join(\", \") + \")\\n\\tError => \" + err);\n            }\n        }), arrows));\n    }\n\n    _createClass(AllCombinator, [{\n        key: \"toString\",\n        value: function toString() {\n            return \"all(\" + this.arrows.map(function (a) {\n                return a.toString();\n            }).join(\", \") + \") :: \" + this.type.toString();\n        }\n    }, {\n        key: \"call\",\n        value: function call(x, p, k, h) {\n            var _this22 = this;\n\n            var numFinished = 0;\n            var callResults = this.arrows.map(function (x) {\n                return null;\n            });\n\n            this.arrows.forEach(function (a, i) {\n                a.call(x[i], p, function (y) {\n                    callResults[i] = y;\n\n                    // Once results array is finished, continue\n                    if (++numFinished == _this22.arrows.length) {\n                        k(callResults);\n                    }\n                }, h);\n            });\n        }\n    }]);\n\n    return AllCombinator;\n}(Combinator);\n\nvar AnyCombinator = function (_Combinator5) {\n    _inherits(AnyCombinator, _Combinator5);\n\n    function AnyCombinator(arrows) {\n        _classCallCheck(this, AnyCombinator);\n\n        arrows = getNonNullArrows(arrows);\n\n        return _possibleConstructorReturn(this, (AnyCombinator.__proto__ || Object.getPrototypeOf(AnyCombinator)).call(this, _construct(function () {\n            var sty = sanitizeTypes(arrows);\n\n            try {\n                var arg = ParamType.fresh();\n                var out = ParamType.fresh();\n                var ncs = new ConstraintSet([]);\n                var err = [];\n\n                sty.forEach(function (t, i) {\n                    ncs = ncs.concat(t.constraints);\n                    err = err.concat(t.errors);\n\n                    ncs = ncs.add(new Constraint(arg, t.arg));\n                    ncs = ncs.add(new Constraint(t.out, out));\n                });\n\n                return new ArrowType(arg, out, ncs, err);\n            } catch (err) {\n                var message = void 0;\n                var location = getLocation(err.stack);\n\n                if (location) {\n                    message = \"Unable to any arrows at: \" + location;\n                } else {\n                    message = \"Unable to any arrows\";\n                }\n\n                throw new ComposeError(message + \"\\n\\tInput => Any(\" + sty.join(\", \") + \")\\n\\tError => \" + err);\n            }\n        }), arrows));\n    }\n\n    _createClass(AnyCombinator, [{\n        key: \"toString\",\n        value: function toString() {\n            return \"any(\" + this.arrows.map(function (a) {\n                return a.toString();\n            }).join(\", \") + \") :: \" + this.type.toString();\n        }\n    }, {\n        key: \"call\",\n        value: function call(x, p, k, h) {\n            // Note: This must be done at execution time instead of construction\n            // time because a recursive arrow may present itself as falsely async.\n\n            if (!this.arrows.every(function (a) {\n                return a.isAsync();\n            })) {\n                throw new Error(\"Any combinator requires asynchronous arrow arguments\");\n            }\n\n            var progress = this.arrows.map(function () {\n                return new Progress(true);\n            });\n\n            // If combinator is canceled, cancel all children\n            p.addCanceler(function () {\n                return progress.forEach(function (p) {\n                    return p.cancel();\n                });\n            });\n\n            this.arrows.forEach(function (a, i) {\n                // When arrow[i] progresses, cancel others\n                progress[i].addObserver(function () {\n                    p.advance();\n\n                    progress.forEach(function (p, j) {\n                        if (j != i) {\n                            p.cancel();\n                        }\n                    });\n                });\n\n                // TODO - clone value\n                // Kick off execution synchronously\n                a.call(x, progress[i], k, h);\n            });\n        }\n    }, {\n        key: \"isAsync\",\n        value: function isAsync() {\n            return true;\n        }\n    }]);\n\n    return AnyCombinator;\n}(Combinator);\n\nvar TryCombinator = function (_Combinator6) {\n    _inherits(TryCombinator, _Combinator6);\n\n    function TryCombinator(a, s, f) {\n        _classCallCheck(this, TryCombinator);\n\n        return _possibleConstructorReturn(this, (TryCombinator.__proto__ || Object.getPrototypeOf(TryCombinator)).call(this, _construct(function () {\n            var sta = sanitizeTypes([a])[0];\n            var sts = sanitizeTypes([s])[0];\n            var stf = sanitizeTypes([f])[0];\n\n            try {\n                var arg = sta.arg;\n                var out = ParamType.fresh();\n                var ncs = new ConstraintSet([]);\n                var err = [];\n\n                ncs = ncs.concat(sta.constraints);\n                ncs = ncs.concat(sts.constraints);\n                ncs = ncs.concat(stf.constraints);\n                ncs = ncs.add(new Constraint(sta.out, sts.arg));\n                ncs = ncs.add(new Constraint(sts.out, out));\n                ncs = ncs.add(new Constraint(stf.out, out));\n\n                sta.errors.forEach(function (e, i) {\n                    ncs = ncs.add(new Constraint(e, stf.arg));\n                });\n\n                err = err.concat(sts.errors);\n                err = err.concat(stf.errors);\n\n                return new ArrowType(arg, out, ncs, err);\n            } catch (err) {\n                var message = void 0;\n                var location = getLocation(err.stack);\n\n                if (location) {\n                    message = \"Unable to try arrows at: \" + location;\n                } else {\n                    message = \"Unable to try arrows\";\n                }\n\n                throw new ComposeError(message + \"\\n\\tInput => Try(\" + [sta, sts, stf].join(\", \") + \")\\n\\tError => \" + err);\n            }\n        }), [a, s, f]));\n    }\n\n    _createClass(TryCombinator, [{\n        key: \"toString\",\n        value: function toString() {\n            return \"try(\" + this.arrows.map(function (a) {\n                return a.toString();\n            }).join(\", \") + \") :: \" + this.type.toString();\n        }\n    }, {\n        key: \"call\",\n        value: function call(x, p, k, h) {\n            var _this25 = this;\n\n            // Invoke original error callback \"h\" if either\n            // callback creates an error value. This allows\n            // nesting of error callbacks.\n\n            var branch = new Progress(true);\n            p.addCanceler(function () {\n                return branch.cancel();\n            });\n            branch.addObserver(function () {\n                return p.advance();\n            });\n\n            this.arrows[0].call(x, branch, function (y) {\n                return _this25.arrows[1].call(y, p, k, h);\n            }, function (z) {\n                branch.cancel();\n                _this25.arrows[2].call(z, p, k, h);\n            });\n        }\n    }, {\n        key: \"isAsync\",\n        value: function isAsync() {\n            return (this.arrows[0].isAsync() || this.arrows[1].isAsync()) && this.arrows[2].isAsync();\n        }\n    }]);\n\n    return TryCombinator;\n}(Combinator);\n\n//\n// Fix-Point Combinator\n//\n\nArrow.fix = function (ctor) {\n    var arg = ParamType.fresh(true);\n    var out = ParamType.fresh(true);\n\n    var p = new ProxyArrow(arg, out);\n    var a = ctor(p);\n    p.freeze(a);\n\n    if (!(a instanceof Arrow)) {\n        throw new Error(\"Fix constructor must return an arrow\");\n    }\n\n    var t = a.type.toString();\n\n    var map = {};\n    descendants(arg).forEach(function (d) {\n        return map[d.id] = arg;\n    });\n    descendants(out).forEach(function (d) {\n        return map[d.id] = out;\n    });\n\n    arg.noreduce = false;\n    out.noreduce = false;\n    a.type.substitute(map);\n\n    a.type.constraints = a.type.constraints.add(new Constraint(a.type.arg, arg));\n    a.type.constraints = a.type.constraints.add(new Constraint(arg, a.type.arg));\n    a.type.constraints = a.type.constraints.add(new Constraint(a.type.out, out));\n    a.type.constraints = a.type.constraints.add(new Constraint(out, a.type.out));\n\n    try {\n        a.type.resolve();\n    } catch (err) {\n        var message = void 0;\n        var location = getLocation(err.stack);\n\n        if (location) {\n            message = \"Unable to fix arrow at: \" + location;\n        } else {\n            message = \"Unable to fix arrow\";\n        }\n\n        throw new ComposeError(message + \"\\n\\tInput => Fix(\" + t + \")\\n\\tError => \" + err);\n    }\n\n    return a;\n};\n\nvar ProxyArrow = function (_Arrow6) {\n    _inherits(ProxyArrow, _Arrow6);\n\n    function ProxyArrow(arg, out) {\n        _classCallCheck(this, ProxyArrow);\n\n        var _this26 = _possibleConstructorReturn(this, (ProxyArrow.__proto__ || Object.getPrototypeOf(ProxyArrow)).call(this, _construct(function () {\n            return new ArrowType(arg, out);\n        })));\n\n        _this26.arrow = null;\n        return _this26;\n    }\n\n    _createClass(ProxyArrow, [{\n        key: \"toString\",\n        value: function toString() {\n            if (this.arrow != null) {\n                return \"omega :: \" + this.arrow.type.toString();\n            }\n\n            return \"omega :: ???\";\n        }\n    }, {\n        key: \"freeze\",\n        value: function freeze(arrow) {\n            this.arrow = arrow;\n        }\n    }, {\n        key: \"call\",\n        value: function call(x, p, k, h) {\n            return this.ensureFrozen(function (a) {\n                return a.call(x, p, k, h);\n            });\n        }\n    }, {\n        key: \"equals\",\n        value: function equals(that) {\n            return this.ensureFrozen(function (a) {\n                return a.equals(that);\n            });\n        }\n    }, {\n        key: \"isAsync\",\n        value: function isAsync() {\n            return this.ensureFrozen(function (a) {\n                return a.isAsync();\n            });\n        }\n    }, {\n        key: \"ensureFrozen\",\n        value: function ensureFrozen(f) {\n            if (this.arrow != null) {\n                return f(this.arrow);\n            }\n\n            throw new Error(\"Proxy not frozen\");\n        }\n    }]);\n\n    return ProxyArrow;\n}(Arrow);\n\nfunction getNonNullArrows(arrows) {\n    var filtered = getNonNullElems(arrows);\n    filtered.forEach(ensureArrow);\n    return filtered;\n}\n\nfunction getNonNullElems(arrows) {\n    var filtered = arrows.filter(function (a) {\n        return a != null;\n    });\n    if (filtered.length == 0) {\n        throw new ComposeError(\"Combinator contains no non-null arguments.\");\n    }\n\n    return filtered;\n}\n\nfunction ensureArrow(arrow) {\n    if (!(arrow instanceof Arrow)) {\n        throw new ComposeError(\"Passed non-arrow (\" + JSON.stringify(arrow) + \") to combinator\");\n    }\n}\n\nfunction descendants(param) {\n    var children = [param];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = param.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var child = _step.value;\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = descendants(child)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var descendant = _step2.value;\n\n                    children.push(descendant);\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n\n    return children;\n}\n\nfunction format(format, args) {\n    return format.replace(/{(\\d+)}/g, function (match, number) {\n        return typeof args[number] != \"undefined\" ? args[number] : match;\n    });\n}\n\nvar Type = function () {\n    function Type() {\n        _classCallCheck(this, Type);\n    }\n\n    _createClass(Type, [{\n        key: \"equals\",\n        value: function equals(that) {\n            throw new Error(\"Equals undefined\");\n        }\n    }, {\n        key: \"check\",\n        value: function check(value) {\n            throw new TypeClash(this, value);\n        }\n    }, {\n        key: \"isParam\",\n        value: function isParam() {\n            return false;\n        }\n    }, {\n        key: \"isConcrete\",\n        value: function isConcrete() {\n            return true;\n        }\n    }, {\n        key: \"harvest\",\n        value: function harvest() {\n            return [];\n        }\n    }, {\n        key: \"substitute\",\n        value: function substitute(map) {\n            return this;\n        }\n    }, {\n        key: \"sanitize\",\n        value: function sanitize(map) {\n            return this;\n        }\n    }]);\n\n    return Type;\n}();\n\nvar uniqid = 0;\n\nvar ParamType = function (_Type) {\n    _inherits(ParamType, _Type);\n\n    _createClass(ParamType, null, [{\n        key: \"fresh\",\n        value: function fresh(noreduce) {\n            return new ParamType(++uniqid, noreduce || false);\n        }\n    }]);\n\n    function ParamType(id, noreduce) {\n        _classCallCheck(this, ParamType);\n\n        var _this27 = _possibleConstructorReturn(this, (ParamType.__proto__ || Object.getPrototypeOf(ParamType)).call(this));\n\n        _this27.id = id;\n        _this27.noreduce = noreduce;\n        _this27.children = [];\n        return _this27;\n    }\n\n    _createClass(ParamType, [{\n        key: \"equals\",\n        value: function equals(that) {\n            return that instanceof ParamType && this.id === that.id;\n        }\n    }, {\n        key: \"toString\",\n        value: function toString() {\n            return \"'\" + this.id;\n        }\n    }, {\n        key: \"check\",\n        value: function check(value) {}\n    }, {\n        key: \"isParam\",\n        value: function isParam() {\n            return true;\n        }\n    }, {\n        key: \"isConcrete\",\n        value: function isConcrete() {\n            return false;\n        }\n    }, {\n        key: \"harvest\",\n        value: function harvest() {\n            return [this];\n        }\n    }, {\n        key: \"substitute\",\n        value: function substitute(map) {\n            return this.id in map ? map[this.id] : this;\n        }\n    }, {\n        key: \"sanitize\",\n        value: function sanitize(map) {\n            if (!(this.id in map)) {\n                var p = ParamType.fresh(this.noreduce);\n                this.children.push(p);\n                map[this.id] = p;\n            }\n\n            return map[this.id];\n        }\n    }]);\n\n    return ParamType;\n}(Type);\n\nvar TopType = function (_Type2) {\n    _inherits(TopType, _Type2);\n\n    function TopType() {\n        _classCallCheck(this, TopType);\n\n        return _possibleConstructorReturn(this, (TopType.__proto__ || Object.getPrototypeOf(TopType)).apply(this, arguments));\n    }\n\n    _createClass(TopType, [{\n        key: \"equals\",\n        value: function equals(that) {\n            return that instanceof TopType;\n        }\n    }, {\n        key: \"toString\",\n        value: function toString() {\n            return \"_\";\n        }\n    }, {\n        key: \"check\",\n        value: function check(value) {}\n    }]);\n\n    return TopType;\n}(Type);\n\nvar runtimeCheckers = {\n    \"Bool\": function Bool(v) {\n        return v === true || v === false;\n    },\n    \"Number\": function Number(v) {\n        return typeof v == \"number\";\n    },\n    \"String\": function String(v) {\n        return typeof v == \"string\";\n    },\n    \"Elem\": function Elem(v) {\n        return v instanceof jQuery;\n    },\n    \"Event\": function Event(v) {\n        return false;\n    } // TODO\n};\n\nfunction checkNamedType(name, value) {\n    var checker = runtimeCheckers[name];\n\n    if (checker) {\n        return checker(value);\n    } else {\n        throw new Error(\"Named type \\\"\" + name + \"\\\" does not have an associated checker.\");\n    }\n}\n\nvar NamedType = function (_Type3) {\n    _inherits(NamedType, _Type3);\n\n    function NamedType(name) {\n        _classCallCheck(this, NamedType);\n\n        var _this29 = _possibleConstructorReturn(this, (NamedType.__proto__ || Object.getPrototypeOf(NamedType)).call(this));\n\n        _this29.name = name;\n        return _this29;\n    }\n\n    _createClass(NamedType, [{\n        key: \"equals\",\n        value: function equals(that) {\n            return that instanceof NamedType && this.name === that.name;\n        }\n    }, {\n        key: \"toString\",\n        value: function toString() {\n            return this.name;\n        }\n    }, {\n        key: \"check\",\n        value: function check(value) {\n            if (!checkNamedType(this.name, value)) {\n                _get(NamedType.prototype.__proto__ || Object.getPrototypeOf(NamedType.prototype), \"check\", this).call(this, value);\n            }\n        }\n    }]);\n\n    return NamedType;\n}(Type);\n\nvar SumType = function (_Type4) {\n    _inherits(SumType, _Type4);\n\n    function SumType(names) {\n        _classCallCheck(this, SumType);\n\n        var _this30 = _possibleConstructorReturn(this, (SumType.__proto__ || Object.getPrototypeOf(SumType)).call(this));\n\n        _this30.names = names.unique().sort();\n        return _this30;\n    }\n\n    _createClass(SumType, [{\n        key: \"equals\",\n        value: function equals(that) {\n            if (that instanceof SumType) {\n                return this.names.length === that.names.length && this.names.every(function (n, i) {\n                    return n === that.names[i];\n                });\n            }\n\n            return false;\n        }\n    }, {\n        key: \"toString\",\n        value: function toString() {\n            return this.names.join(\"+\");\n        }\n    }, {\n        key: \"check\",\n        value: function check(value) {\n            if (!this.names.some(function (name) {\n                return checkNamedType(name, value);\n            })) {\n                _get(SumType.prototype.__proto__ || Object.getPrototypeOf(SumType.prototype), \"check\", this).call(this, value);\n            }\n        }\n    }]);\n\n    return SumType;\n}(Type);\n\nvar TaggedUnionType = function (_Type5) {\n    _inherits(TaggedUnionType, _Type5);\n\n    function TaggedUnionType(map) {\n        _classCallCheck(this, TaggedUnionType);\n\n        var _this31 = _possibleConstructorReturn(this, (TaggedUnionType.__proto__ || Object.getPrototypeOf(TaggedUnionType)).call(this));\n\n        _this31.vals = map;\n        _this31.keys = Object.keys(map).sort();\n        return _this31;\n    }\n\n    _createClass(TaggedUnionType, [{\n        key: \"equals\",\n        value: function equals(that) {\n            var _this32 = this;\n\n            if (that instanceof TaggedUnionType) {\n                return this.keys.length === that.keys.length && this.keys.every(function (k) {\n                    return _this32.vals[k].equals(that.vals[k]);\n                });\n            }\n\n            return false;\n        }\n    }, {\n        key: \"toString\",\n        value: function toString() {\n            var _this33 = this;\n\n            return \"<\" + this.keys.map(function (k) {\n                return k + \": \" + _this33.vals[k].toString();\n            }).join(\", \") + \">\";\n        }\n    }, {\n        key: \"check\",\n        value: function check(value) {\n            try {\n                for (var key in this.keys) {\n                    if (value.hasTag(key)) {\n                        return this.vals[key].check(value.value());\n                    }\n                }\n\n                return false;\n            } catch (err) {\n                _get(TaggedUnionType.prototype.__proto__ || Object.getPrototypeOf(TaggedUnionType.prototype), \"check\", this).call(this, value);\n            }\n        }\n    }, {\n        key: \"isConcrete\",\n        value: function isConcrete() {\n            var _this34 = this;\n\n            return this.keys.every(function (k) {\n                return _this34.vals[k].isConcrete();\n            });\n        }\n    }, {\n        key: \"harvest\",\n        value: function harvest() {\n            var _this35 = this;\n\n            return this.keys.reduce(function (acc, k) {\n                return acc.concat(_this35.vals[k].harvest());\n            }, []);\n        }\n    }, {\n        key: \"substitute\",\n        value: function substitute(map) {\n            var _this36 = this;\n\n            var vals = {};\n            this.keys.forEach(function (k) {\n                vals[k] = _this36.vals[k].substitute(map);\n            });\n\n            return new TaggedUnionType(vals);\n        }\n    }, {\n        key: \"sanitize\",\n        value: function sanitize(map) {\n            var _this37 = this;\n\n            var vals = {};\n            this.keys.forEach(function (k) {\n                vals[k] = _this37.vals[k].sanitize(map);\n            });\n\n            return new TaggedUnionType(vals);\n        }\n    }]);\n\n    return TaggedUnionType;\n}(Type);\n\nvar ArrayType = function (_Type6) {\n    _inherits(ArrayType, _Type6);\n\n    function ArrayType(type) {\n        _classCallCheck(this, ArrayType);\n\n        var _this38 = _possibleConstructorReturn(this, (ArrayType.__proto__ || Object.getPrototypeOf(ArrayType)).call(this));\n\n        _this38.type = type;\n        return _this38;\n    }\n\n    _createClass(ArrayType, [{\n        key: \"equals\",\n        value: function equals(that) {\n            if (that instanceof ArrayType) {\n                return this.type.equals(that.type);\n            }\n\n            return false;\n        }\n    }, {\n        key: \"toString\",\n        value: function toString() {\n            return \"[\" + this.type.toString() + \"]\";\n        }\n    }, {\n        key: \"check\",\n        value: function check(value) {\n            var _this39 = this;\n\n            if (value && value.constructor === Array) {\n                value.forEach(function (v) {\n                    return _this39.type.check(v);\n                });\n            } else {\n                _get(ArrayType.prototype.__proto__ || Object.getPrototypeOf(ArrayType.prototype), \"check\", this).call(this, value);\n            }\n        }\n    }, {\n        key: \"isConcrete\",\n        value: function isConcrete() {\n            return this.type.isConcrete();\n        }\n    }, {\n        key: \"harvest\",\n        value: function harvest() {\n            return this.type.harvest();\n        }\n    }, {\n        key: \"substitute\",\n        value: function substitute(map) {\n            return new ArrayType(this.type.substitute(map));\n        }\n    }, {\n        key: \"sanitize\",\n        value: function sanitize(map) {\n            return new ArrayType(this.type.sanitize(map));\n        }\n    }]);\n\n    return ArrayType;\n}(Type);\n\nvar TupleType = function (_Type7) {\n    _inherits(TupleType, _Type7);\n\n    function TupleType(types) {\n        _classCallCheck(this, TupleType);\n\n        var _this40 = _possibleConstructorReturn(this, (TupleType.__proto__ || Object.getPrototypeOf(TupleType)).call(this));\n\n        _this40.types = types;\n        return _this40;\n    }\n\n    _createClass(TupleType, [{\n        key: \"equals\",\n        value: function equals(that) {\n            if (that instanceof TupleType) {\n                return this.types.length === that.types.length && this.types.every(function (t, i) {\n                    return t.equals(that.types[i]);\n                });\n            }\n\n            return false;\n        }\n    }, {\n        key: \"toString\",\n        value: function toString() {\n            return \"(\" + this.types.map(function (t) {\n                return t.toString();\n            }).join(\", \") + \")\";\n        }\n    }, {\n        key: \"check\",\n        value: function check(value) {\n            var _this41 = this;\n\n            if (value && value.constructor === Array) {\n                value.forEach(function (v, i) {\n                    return _this41.types[i].check(v);\n                });\n            } else {\n                _get(TupleType.prototype.__proto__ || Object.getPrototypeOf(TupleType.prototype), \"check\", this).call(this, value);\n            }\n        }\n    }, {\n        key: \"isConcrete\",\n        value: function isConcrete() {\n            return this.types.every(function (t) {\n                return t.isConcrete();\n            });\n        }\n    }, {\n        key: \"harvest\",\n        value: function harvest() {\n            return this.types.reduce(function (acc, t) {\n                return acc.concat(t.harvest());\n            }, []);\n        }\n    }, {\n        key: \"substitute\",\n        value: function substitute(map) {\n            return new TupleType(this.types.map(function (t) {\n                return t.substitute(map);\n            }));\n        }\n    }, {\n        key: \"sanitize\",\n        value: function sanitize(map) {\n            return new TupleType(this.types.map(function (t) {\n                return t.sanitize(map);\n            }));\n        }\n    }]);\n\n    return TupleType;\n}(Type);\n\nvar RecordType = function (_Type8) {\n    _inherits(RecordType, _Type8);\n\n    function RecordType(map) {\n        _classCallCheck(this, RecordType);\n\n        var _this42 = _possibleConstructorReturn(this, (RecordType.__proto__ || Object.getPrototypeOf(RecordType)).call(this));\n\n        _this42.vals = map;\n        _this42.keys = Object.keys(map).sort();\n        return _this42;\n    }\n\n    _createClass(RecordType, [{\n        key: \"equals\",\n        value: function equals(that) {\n            var _this43 = this;\n\n            if (that instanceof RecordType) {\n                return this.keys.length === that.keys.length && this.keys.every(function (k) {\n                    return _this43.vals[k].equals(that.vals[k]);\n                });\n            }\n\n            return false;\n        }\n    }, {\n        key: \"toString\",\n        value: function toString() {\n            var _this44 = this;\n\n            return \"{\" + this.keys.map(function (k) {\n                return k + \": \" + _this44.vals[k].toString();\n            }).join(\", \") + \"}\";\n        }\n    }, {\n        key: \"check\",\n        value: function check(value) {\n            var _this45 = this;\n\n            try {\n                this.keys.forEach(function (k) {\n                    _this45.vals[k].check(value[k]);\n                });\n            } catch (err) {\n                _get(RecordType.prototype.__proto__ || Object.getPrototypeOf(RecordType.prototype), \"check\", this).call(this, value);\n            }\n        }\n    }, {\n        key: \"isConcrete\",\n        value: function isConcrete() {\n            var _this46 = this;\n\n            return this.keys.every(function (k) {\n                return _this46.vals[k].isConcrete();\n            });\n        }\n    }, {\n        key: \"harvest\",\n        value: function harvest() {\n            var _this47 = this;\n\n            return this.keys.reduce(function (acc, k) {\n                return acc.concat(_this47.vals[k].harvest());\n            }, []);\n        }\n    }, {\n        key: \"substitute\",\n        value: function substitute(map) {\n            var _this48 = this;\n\n            var vals = {};\n            this.keys.forEach(function (k) {\n                vals[k] = _this48.vals[k].substitute(map);\n            });\n\n            return new RecordType(vals);\n        }\n    }, {\n        key: \"sanitize\",\n        value: function sanitize(map) {\n            var _this49 = this;\n\n            var vals = {};\n            this.keys.forEach(function (k) {\n                vals[k] = _this49.vals[k].sanitize(map);\n            });\n\n            return new RecordType(vals);\n        }\n    }]);\n\n    return RecordType;\n}(Type);\n\nvar TypeClash = function (_Error2) {\n    _inherits(TypeClash, _Error2);\n\n    function TypeClash(type, value) {\n        _classCallCheck(this, TypeClash);\n\n        var _this50 = _possibleConstructorReturn(this, (TypeClash.__proto__ || Object.getPrototypeOf(TypeClash)).call(this));\n\n        _this50.type = type;\n        _this50.value = value;\n        return _this50;\n    }\n\n    _createClass(TypeClash, [{\n        key: \"toString\",\n        value: function toString() {\n            return \"Runtime type assertion failure: Expected \" + this.type.toString() + \"\\\", got \\\"\" + JSON.stringify(this.value) + \"\\\".\";\n        }\n    }]);\n\n    return TypeClash;\n}(Error);\n\nvar Constraint = function () {\n    function Constraint(lower, upper) {\n        _classCallCheck(this, Constraint);\n\n        this.lower = lower;\n        this.upper = upper;\n    }\n\n    _createClass(Constraint, [{\n        key: \"equals\",\n        value: function equals(that) {\n            if (that instanceof Constraint) {\n                return this.lower.equals(that.lower) && this.upper.equals(that.upper);\n            }\n\n            return false;\n        }\n    }, {\n        key: \"toString\",\n        value: function toString() {\n            return this.lower.toString() + \" <= \" + this.upper.toString();\n        }\n    }, {\n        key: \"isUseless\",\n        value: function isUseless() {\n            return this.lower.equals(this.upper) || this.upper instanceof TopType;\n        }\n    }, {\n        key: \"isConsistent\",\n        value: function isConsistent() {\n            var a = this.lower;\n            var b = this.upper;\n\n            if (a instanceof NamedType || a instanceof SumType) {\n                if (b instanceof NamedType || b instanceof SumType) {\n                    var na = a instanceof NamedType ? [a] : a.names;\n                    var nb = b instanceof NamedType ? [b] : b.names;\n                    return na.every(function (t1) {\n                        return nb.some(function (t2) {\n                            return t1.equals(t2);\n                        });\n                    });\n                }\n            }\n\n            if (a instanceof ArrayType && b instanceof ArrayType) return true;\n            if (a instanceof TupleType && b instanceof TupleType) return b.types.length <= a.types.length;\n            if (a instanceof TaggedUnionType && b instanceof TaggedUnionType) return a.keys.every(function (k) {\n                return b.keys.indexOf(k) >= 0;\n            });\n            if (a instanceof RecordType && b instanceof RecordType) return b.keys.every(function (k) {\n                return a.keys.indexOf(k) >= 0;\n            });\n\n            return b instanceof TopType || a.isParam() || b.isParam();\n        }\n    }, {\n        key: \"unary\",\n        value: function unary() {\n            var _this51 = this;\n\n            if (this.lower instanceof ArrayType && this.upper instanceof ArrayType) {\n                return [new Constraint(this.lower.type, this.upper.type)];\n            }\n\n            if (this.lower instanceof TupleType && this.upper instanceof TupleType) {\n                return this.upper.types.filter(function (t, i) {\n                    return i < _this51.lower.types.length;\n                }).map(function (t, i) {\n                    return new Constraint(_this51.lower.types[i], t);\n                });\n            }\n\n            if (this.lower instanceof TaggedUnionType && this.upper instanceof TaggedUnionType) {\n                return this.lower.keys.filter(function (k) {\n                    return _this51.upper.keys.indexOf(k) >= 0;\n                }).map(function (k) {\n                    return new Constraint(_this51.lower.vals[k], _this51.upper.vals[k]);\n                });\n            }\n\n            if (this.lower instanceof RecordType && this.upper instanceof RecordType) {\n                return this.upper.keys.filter(function (k) {\n                    return _this51.lower.keys.indexOf(k) >= 0;\n                }).map(function (k) {\n                    return new Constraint(_this51.lower.vals[k], _this51.upper.vals[k]);\n                });\n            }\n\n            return [];\n        }\n    }, {\n        key: \"binary\",\n        value: function binary(that) {\n            if (this.upper.equals(that.lower)) {\n                return [new Constraint(this.lower, that.upper)];\n            }\n\n            if (this.lower.equals(that.upper)) {\n                return [new Constraint(that.lower, this.upper)];\n            }\n\n            return [];\n        }\n    }]);\n\n    return Constraint;\n}();\n\nvar ConstraintSet = function () {\n    function ConstraintSet(constraints) {\n        _classCallCheck(this, ConstraintSet);\n\n        this.constraints = constraints.filter(function (c) {\n            return !c.isUseless();\n        });\n        var inconsistent = constraints.filter(function (c) {\n            return !c.isConsistent();\n        });\n\n        if (inconsistent.length != 0) {\n            throw new Error(\"Inconsistent constraints: [\" + inconsistent.map(function (c) {\n                return c.toString();\n            }).join(\", \") + \"]\");\n        }\n    }\n\n    _createClass(ConstraintSet, [{\n        key: \"equals\",\n        value: function equals(that) {\n            if (this.constraints.length == that.constraints.length) {\n                for (var i = 0; i < this.constraints.length; i++) {\n                    if (!this.contains(this.constraints[i])) {\n                        return false;\n                    }\n                }\n\n                return true;\n            }\n\n            return false;\n        }\n    }, {\n        key: \"contains\",\n        value: function contains(constraint) {\n            for (var i = 0; i < this.constraints.length; i++) {\n                if (this.constraints[i].equals(constraint)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }, {\n        key: \"toString\",\n        value: function toString() {\n            return \"{\" + this.constraints.map(function (c) {\n                return c.toString();\n            }).join(\", \") + \"}\";\n        }\n    }, {\n        key: \"add\",\n        value: function add(constraint) {\n            if (this.constraints.some(function (c) {\n                return c.equals(constraint);\n            })) {\n                return this;\n            }\n\n            return new ConstraintSet(this.constraints.concat([constraint]));\n        }\n    }, {\n        key: \"addAll\",\n        value: function addAll(constraints) {\n            return constraints.reduce(function (set, c) {\n                return set.add(c);\n            }, this);\n        }\n    }, {\n        key: \"concat\",\n        value: function concat(cs) {\n            return this.addAll(cs.constraints);\n        }\n    }, {\n        key: \"substitute\",\n        value: function substitute(map) {\n            return new ConstraintSet(this.constraints.map(function (c) {\n                return new Constraint(c.lower.substitute(map), c.upper.substitute(map));\n            }));\n        }\n    }, {\n        key: \"sanitize\",\n        value: function sanitize(map) {\n            return new ConstraintSet(this.constraints.map(function (c) {\n                return new Constraint(c.lower.sanitize(map), c.upper.sanitize(map));\n            }));\n        }\n    }]);\n\n    return ConstraintSet;\n}();\n\n//\n// Arrow Type\n//\n\nvar ArrowType = function () {\n    function ArrowType(arg, out, constraints, errors) {\n        var _this52 = this;\n\n        _classCallCheck(this, ArrowType);\n\n        this.arg = arg;\n        this.out = out;\n        this.constraints = constraints || new ConstraintSet([]);\n        this.errors = [];\n\n        var _loop = function _loop(type) {\n            if (!_this52.errors.some(function (e) {\n                return e.equals(type);\n            })) {\n                _this52.errors.push(type);\n            }\n        };\n\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n            for (var _iterator3 = (errors || [])[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                var type = _step3.value;\n\n                _loop(type);\n            }\n        } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                    _iterator3.return();\n                }\n            } finally {\n                if (_didIteratorError3) {\n                    throw _iteratorError3;\n                }\n            }\n        }\n\n        this.resolve();\n    }\n\n    _createClass(ArrowType, [{\n        key: \"toString\",\n        value: function toString() {\n            var type = this.arg.toString() + \" ~> \" + this.out.toString();\n\n            if (this.constraints.constraints.length > 0 || this.errors.length > 0) {\n                type += \" \\\\ (\";\n                type += this.constraints.toString();\n                type += \", {\";\n                type += this.errors.map(function (t) {\n                    return t.toString();\n                }).join(\", \");\n                type += \"})\";\n            }\n\n            return type;\n        }\n    }, {\n        key: \"resolve\",\n        value: function resolve() {\n            var initial = this.constraints;\n\n            while (true) {\n                this.constraints = this.closure();\n                this.constraints = this.mergeConcreteBounds();\n\n                var map = this.collectBounds();\n\n                if (Object.getOwnPropertyNames(map).length === 0) {\n                    break;\n                }\n\n                this.substitute(map);\n            }\n\n            var cs = this.prune();\n\n            if (cs.constraints.length === this.constraints.constraints.length || initial.equals(cs)) {\n                return;\n            }\n\n            this.constraints = cs;\n            this.resolve();\n        }\n    }, {\n        key: \"substitute\",\n        value: function substitute(map) {\n            this.arg = this.arg.substitute(map);\n            this.out = this.out.substitute(map);\n            this.constraints = this.constraints.substitute(map);\n            this.errors = this.errors.map(function (e) {\n                return e.substitute(map);\n            });\n        }\n\n        /**\n         * Add the result of unary and binary closure rules on each constraint in\n         * the set until no new constraints are produced (a fixed point reached).\n         */\n\n    }, {\n        key: \"closure\",\n        value: function closure() {\n            var cs = [];\n            var wl = Array.copy(this.constraints.constraints);\n\n            var _loop2 = function _loop2() {\n                var w = wl.pop();\n\n                if (!cs.some(function (c) {\n                    return c.equals(w);\n                })) {\n                    w.unary().forEach(function (c) {\n                        return wl.push(c);\n                    });\n\n                    var _iteratorNormalCompletion4 = true;\n                    var _didIteratorError4 = false;\n                    var _iteratorError4 = undefined;\n\n                    try {\n                        for (var _iterator4 = cs[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                            var c = _step4.value;\n\n                            w.binary(c).forEach(function (c) {\n                                return wl.push(c);\n                            });\n                        }\n                    } catch (err) {\n                        _didIteratorError4 = true;\n                        _iteratorError4 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                                _iterator4.return();\n                            }\n                        } finally {\n                            if (_didIteratorError4) {\n                                throw _iteratorError4;\n                            }\n                        }\n                    }\n\n                    cs.push(w);\n                }\n            };\n\n            while (wl.length > 0) {\n                _loop2();\n            }\n\n            return new ConstraintSet(cs);\n        }\n\n        /**\n         * Replace multiple constraints which upper bound or lower bound a param\n         * type with the lub or glb, respectively, of the concrete bound.\n         */\n\n    }, {\n        key: \"mergeConcreteBounds\",\n        value: function mergeConcreteBounds() {\n            var idmap = {};\n            var lower = {};\n            var upper = {};\n            var other = [];\n\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n                for (var _iterator5 = this.constraints.constraints[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                    var c = _step5.value;\n\n                    var _a = c.lower;\n                    var b = c.upper;\n\n                    if (_a.isParam()) idmap[_a.id] = _a;\n                    if (b.isParam()) idmap[b.id] = b;\n\n                    if (_a.isParam() && b.isConcrete()) {\n                        lower[_a.id] = _a.id in lower ? glb(lower[_a.id], b) : b;\n                    } else if (b.isParam() && _a.isConcrete()) {\n                        upper[b.id] = b.id in upper ? lub(upper[b.id], _a) : _a;\n                    } else {\n                        other.push(c);\n                    }\n                }\n            } catch (err) {\n                _didIteratorError5 = true;\n                _iteratorError5 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                        _iterator5.return();\n                    }\n                } finally {\n                    if (_didIteratorError5) {\n                        throw _iteratorError5;\n                    }\n                }\n            }\n\n            if (lower.length === 0 && upper.length === 0) {\n                return null;\n            }\n\n            Object.keys(lower).forEach(function (id) {\n                return other.push(new Constraint(idmap[id], lower[id]));\n            });\n            Object.keys(upper).forEach(function (id) {\n                return other.push(new Constraint(upper[id], idmap[id]));\n            });\n\n            return new ConstraintSet(other);\n        }\n\n        /**\n         * Create a substitution map. A param type p can be replaced by type t iff\n         * one of the following hold:\n         *\n         *    - t <= p and p <= t\n         *    - p^- <= t (and t is sole upper bound of p)\n         *    - t <= p^+ (and t is sole lower bound of p)\n         */\n\n    }, {\n        key: \"collectBounds\",\n        value: function collectBounds() {\n            var map = {};\n\n            function addToMap(p, t) {\n                map[p.id] = t.isParam() && t.id in map ? map[t.id] : t;\n            }\n\n            var cs = this.constraints.constraints;\n            var lowerParam = cs.filter(function (c) {\n                return c.lower.isParam() && !c.lower.noreduce;\n            });\n            var upperParam = cs.filter(function (c) {\n                return c.upper.isParam() && !c.upper.noreduce;\n            });\n\n            lowerParam.forEach(function (c1) {\n                upperParam.forEach(function (c2) {\n                    if (c1.lower.equals(c2.upper) && c1.upper.equals(c2.lower)) {\n                        addToMap(c1.lower, c1.upper);\n                    }\n                });\n            });\n\n            var _polarity = this.polarity(),\n                _polarity2 = _slicedToArray(_polarity, 2),\n                n = _polarity2[0],\n                p = _polarity2[1];\n\n            var negVar = n.filter(function (v) {\n                return !p.some(function (x) {\n                    return x.equals(v);\n                });\n            }); // negative-only params\n            var posVar = p.filter(function (v) {\n                return !n.some(function (x) {\n                    return x.equals(v);\n                });\n            }); // positive-only params\n\n            // Replace negative variables by their sole upper bound, if it exists\n            negVar.map(function (p) {\n                return cs.filter(function (c) {\n                    return c.lower === p;\n                });\n            }).filter(function (cs) {\n                return cs.length === 1;\n            }).forEach(function (c) {\n                addToMap(c[0].lower, c[0].upper);\n            });\n\n            // Replace positive variables by their sole lower bound, if it exists\n            posVar.map(function (p) {\n                return cs.filter(function (c) {\n                    return c.upper === p;\n                });\n            }).filter(function (cs) {\n                return cs.length === 1;\n            }).forEach(function (c) {\n                addToMap(c[0].upper, c[0].lower);\n            });\n\n            return map;\n        }\n\n        /**\n         * Remove all constraints which are in one of the following forms:\n         *\n         *    - t <= t where neither are params\n         *    - a <= b and (a or b) is not in the arrow type\n         *    - t <= p^-\n         *    - p^+ <= t\n         */\n\n    }, {\n        key: \"prune\",\n        value: function prune() {\n            var _polarity3 = this.polarity(),\n                _polarity4 = _slicedToArray(_polarity3, 2),\n                n = _polarity4[0],\n                p = _polarity4[1];\n\n            var params = this.arg.harvest().concat(this.out.harvest()).concat(this.errors);\n\n            return new ConstraintSet(this.constraints.constraints.filter(function (c) {\n                // Keep no-reduce parameters\n                if (c.lower.isParam() && c.lower.noreduce) return true;\n                if (c.upper.isParam() && c.upper.noreduce) return true;\n\n                // Remove non-parameter constraints\n                if (!c.lower.isParam() && !c.upper.isParam()) return false;\n\n                // Remove unknown type variables\n                if (c.lower.isParam() && c.upper.isParam() && !params.some(function (p) {\n                    return p.equals(c.lower);\n                })) return false;\n                if (c.lower.isParam() && c.upper.isParam() && !params.some(function (p) {\n                    return p.equals(c.upper);\n                })) return false;\n\n                // Remove constraints with useless polarity\n                if (c.lower.isParam() && !n.some(function (p) {\n                    return p.equals(c.lower);\n                })) return false;\n                if (c.upper.isParam() && !p.some(function (p) {\n                    return p.equals(c.upper);\n                })) return false;\n\n                return true;\n            }));\n        }\n\n        /**\n         * Determine which variables in arg and out have negative or positive position. This algorithm uses\n         * dumb iteration and may be improved by the use of a worklist. The return value fo this function is\n         * a pair [n, p] where n is the set of negative variables and p is the set of positive variables. If\n         * a variable is both negative and positive it exists in both sets. If a variable is unreachable by\n         * arg or out then it will be absent from both lists.\n         */\n\n    }, {\n        key: \"polarity\",\n        value: function polarity() {\n            var neg = this.arg.harvest();\n            var pos = this.out.harvest().concat(this.errors);\n\n            var changed = true;\n            var negDefs = this.constraints.constraints.filter(function (c) {\n                return c.lower.isParam();\n            }).map(function (c) {\n                return [c.lower, c.upper.harvest()];\n            });\n            var posDefs = this.constraints.constraints.filter(function (c) {\n                return c.upper.isParam();\n            }).map(function (c) {\n                return [c.upper, c.lower.harvest()];\n            });\n\n            while (changed) {\n                changed = false;\n\n                var extraNeg = negDefs.filter(function (_ref3) {\n                    var _ref4 = _slicedToArray(_ref3, 2),\n                        a = _ref4[0],\n                        b = _ref4[1];\n\n                    return neg.some(function (p) {\n                        return p === a;\n                    });\n                }).reduce(function (c, _ref5) {\n                    var _ref6 = _slicedToArray(_ref5, 2),\n                        a = _ref6[0],\n                        b = _ref6[1];\n\n                    return c.concat(b);\n                }, []).filter(function (x) {\n                    return !neg.some(function (p) {\n                        return p === x;\n                    });\n                });\n                var extraPos = posDefs.filter(function (_ref7) {\n                    var _ref8 = _slicedToArray(_ref7, 2),\n                        a = _ref8[0],\n                        b = _ref8[1];\n\n                    return pos.some(function (p) {\n                        return p === a;\n                    });\n                }).reduce(function (c, _ref9) {\n                    var _ref10 = _slicedToArray(_ref9, 2),\n                        a = _ref10[0],\n                        b = _ref10[1];\n\n                    return c.concat(b);\n                }, []).filter(function (x) {\n                    return !pos.some(function (p) {\n                        return p === x;\n                    });\n                });\n\n                if (extraNeg.length > 0 || extraPos.length > 0) {\n                    changed = true;\n                    neg = neg.concat(extraNeg);\n                    pos = pos.concat(extraPos);\n                }\n            }\n\n            return [neg, pos];\n        }\n    }, {\n        key: \"sanitize\",\n        value: function sanitize() {\n            var map = {};\n            var arg = this.arg.sanitize(map);\n            var out = this.out.sanitize(map);\n            var constraints = this.constraints.sanitize(map);\n            var errors = this.errors.map(function (e) {\n                return e.sanitize(map);\n            });\n\n            return new ArrowType(arg, out, constraints, errors);\n        }\n    }]);\n\n    return ArrowType;\n}();\n\n//\n// Type Utilities\n//\n\nfunction sanitizeTypes(arrows) {\n    return arrows.map(function (a) {\n        return a.type;\n    }).map(function (t) {\n        return t.sanitize();\n    });\n}\n\nfunction lub(a, b) {\n    if (a.equals(b)) {\n        return a;\n    }\n\n    if (a instanceof NamedType || a instanceof SumType) {\n        if (b instanceof NamedType || b instanceof SumType) {\n            var na = a instanceof NamedType ? [a] : a.names;\n            var nb = b instanceof NamedType ? [b] : b.names;\n            var nu = na.concat(nb.filter(function (n) {\n                return na.indexOf(n) < 0;\n            }));\n\n            if (nu.length == 1) return new NamedType(nu[0]);\n            if (nu.length >= 2) return new SumType(nu);\n        }\n    }\n\n    if (a instanceof TaggedUnionType && b instanceof TaggedUnionType) {\n        var map = {};\n        b.keys.filter(function (k) {\n            return a.keys.indexOf(k) >= 0;\n        }).forEach(function (k) {\n            map[k] = lub(a.vals[k], b.vals[k]);\n        });\n\n        return new TaggedUnionType(map);\n    }\n\n    if (a instanceof ArrayType && b instanceof ArrayType) {\n        return new ArrayType(lub(a.type, b.type));\n    }\n\n    if (a instanceof TupleType && b instanceof TupleType) {\n        return new TupleType(a.types.length < b.types.length ? a.types.map(function (t, i) {\n            return lub(t, b.types[i]);\n        }) : b.types.map(function (t, i) {\n            return lub(t, a.types[i]);\n        }));\n    }\n\n    if (a instanceof RecordType && b instanceof RecordType) {\n        var _map = {};\n        a.keys.filter(function (k) {\n            return b.keys.indexOf(k) >= 0;\n        }).forEach(function (k) {\n            _map[k] = lub(a.vals[k], b.vals[k]);\n        });\n\n        return new RecordType(_map);\n    }\n\n    return new TopType();\n}\n\nfunction glb(a, b) {\n    if (a.equals(b)) {\n        return a;\n    }\n\n    if (a instanceof TopType) return b;\n    if (b instanceof TopType) return a;\n\n    if (a instanceof NamedType || a instanceof SumType) {\n        if (b instanceof NamedType || b instanceof SumType) {\n            var na = a instanceof NamedType ? [a] : a.names;\n            var nb = b instanceof NamedType ? [b] : b.names;\n            var ni = na.filter(function (t1) {\n                return nb.some(function (t2) {\n                    return t1.equals(t2);\n                });\n            });\n\n            if (ni.length == 1) return new NamedType(ni[0]);\n            if (ni.length >= 2) return new SumType(ni);\n        }\n    }\n\n    if (a instanceof ArrayType && b instanceof ArrayType) {\n        return new ArrayType(glb(a.type, b.type));\n    }\n\n    if (a instanceof TupleType && b instanceof TupleType) {\n        return new TupleType(a.types.length < b.types.length ? b.types.map(function (t, i) {\n            return i >= a.types.length ? t : glb(t, a.types[i]);\n        }) : a.types.map(function (t, i) {\n            return i >= b.types.length ? t : glb(t, b.types[i]);\n        }));\n    }\n\n    if (a instanceof TaggedUnionType && b instanceof TaggedUnionType) {\n        var map = {};\n        a.keys.forEach(function (k) {\n            map[k] = k in map ? glb(map[k], a.vals[k]) : a.vals[k];\n        });\n        b.keys.forEach(function (k) {\n            map[k] = k in map ? glb(map[k], b.vals[k]) : b.vals[k];\n        });\n\n        return new RecordType(map);\n    }\n\n    if (a instanceof RecordType && b instanceof RecordType) {\n        var _map2 = {};\n        a.keys.forEach(function (k) {\n            _map2[k] = k in _map2 ? glb(_map2[k], a.vals[k]) : a.vals[k];\n        });\n        b.keys.forEach(function (k) {\n            _map2[k] = k in _map2 ? glb(_map2[k], b.vals[k]) : b.vals[k];\n        });\n\n        return new RecordType(_map2);\n    }\n\n    throw new Error(\"No greatest lower bound of \\\"\" + a.toString() + \"\\\" and \\\"\" + b.toString() + \"\\\".\");\n}\n\nfunction getLocation(stack) {\n    var r = new RegExp(/(?:https?|file):\\/\\/(.+):(\\d+):\\d+/g);\n\n    var _iteratorNormalCompletion6 = true;\n    var _didIteratorError6 = false;\n    var _iteratorError6 = undefined;\n\n    try {\n        for (var _iterator6 = stack.match(r)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var match = _step6.value;\n\n            var parts = new RegExp(/(?:https?|file):\\/\\/(.+):(\\d+):\\d+/g).exec(match);\n\n            if (!parts[1].endsWith(\"arrows.js\")) {\n                return parts[1] + \":\" + parts[2];\n            }\n        }\n    } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                _iterator6.return();\n            }\n        } finally {\n            if (_didIteratorError6) {\n                throw _iteratorError6;\n            }\n        }\n    }\n\n    return \"\";\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./deps/arrows.es5.js?./node_modules/babel-loader/lib??ref--4");

/***/ }),

/***/ "./node_modules/expose-loader/index.js?LiftedArrow!./deps/arrows.es5.js-exposed":
/*!*****************************************************************************!*\
  !*** ./node_modules/expose-loader?LiftedArrow!./deps/arrows.es5.js-exposed ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {module.exports = global[\"LiftedArrow\"] = __webpack_require__(/*! -!./node_modules/babel-loader/lib??ref--4!./arrows.es5.js */ \"./node_modules/babel-loader/lib/index.js?!./deps/arrows.es5.js\");\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./deps/arrows.es5.js-exposed?./node_modules/expose-loader?LiftedArrow");

/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }),

/***/ "./src/behaviors.js":
/*!**************************!*\
  !*** ./src/behaviors.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* Ideas:\n * We may not have to create a new object for the \"behavior\" callbacks\n * If we just overwrite this.bs correctly, it may work\n * \n * TODO:\n * - Make events work via callbacks\n * \n */\n\nvar Behavior = function () {\n    function Behavior(f) {\n        _classCallCheck(this, Behavior);\n\n        this.f = f;\n        this.isBehavior = true;\n    }\n\n    _createClass(Behavior, [{\n        key: 'transform',\n        value: function transform(time) {\n            return time;\n        }\n    }, {\n        key: 'value',\n        value: function value(time) {\n            return this.f(time);\n        }\n    }, {\n        key: 'behavior',\n        value: function behavior(time) {\n            return this;\n        }\n\n        // Gives the behavior a chance to change its own reference\n        // this happens after any time transforms\n        // ordering for a behavior is transform => switch => return\n\n    }, {\n        key: 'switch',\n        value: function _switch(time) {\n            return this;\n        }\n    }, {\n        key: 'at',\n        value: function at(time) {\n            time = this.transform(time);\n            var b = this.switch(time);\n            return [b.value(time), b.behavior(time)];\n        }\n    }]);\n\n    return Behavior;\n}();\n\n/*\n * BehaviorCombinator is a helper for combining behaviors and allows for taking in additional\n * parameters via its constructor via the \"arity\" parameter.\n *\n * Example: \"class AddThreeNumbers extends BehaviorCombinator(0)\" means you want to make a Behavior named \"AddThreeNumbers\"\n * which accepts 3 behaviors in the constructor and no other arguments. So you could say \"new AddThreeNumbers(1, 2, 3)\"\n * Note how the arguments are lifted into behavior values. These 3 behaviors can be accessed in the value function by their \n * array \"this.bs\" or through \"this.b1\" (to select the first behavior passed in the constructor), \"this.b2\", or \"this.b3\".\n *\n * Example: \"class AddTwoNumbersPlusAConstant extends BehaviorCombinator(1)\" means you want to make a Behavior which\n * accepts 2 behaviors and 1 number as an argument. So you could say \"new AddTwoNumbersPlusAConstant(3, 4, 1)\". Note\n * that 3 and 4 will be lifted to behaviors while the 1 will _not_ be lifted. You can access the \"3\" and \"4\" behaviors with\n * \"this.b1\" and \"this.b2\" respectively. Also you can access the constant Number \"1\" using \"this.a1\". If you used \"BehaviorCombinator(2)\",\n * then it would have taken another position in the constructor for a constant (at the end), and that argument could be accessed with\n * \"this.a2\".\n */\n\n\nvar cache = {};\nfunction BehaviorCombinator() {\n    var arity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    if (cache[arity]) {\n        return cache[arity];\n    }\n\n    return cache[arity] = function (_Behavior) {\n        _inherits(_class, _Behavior);\n\n        function _class() {\n            _classCallCheck(this, _class);\n\n            var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this));\n\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n            }\n\n            var as = args.splice(args.length - arity);\n            _this.as = as;\n            for (var i = 0; i < _this.as.length; ++i) {\n                _this['a' + (i + 1)] = _this.as[i];\n            }\n\n            _this.bs = args.map(lift);\n            return _this;\n        }\n\n        _createClass(_class, [{\n            key: 'behavior',\n            value: function behavior(time) {\n                return new (Function.prototype.bind.apply(this.constructor, [null].concat(_toConsumableArray(this.bs.concat(this.as)))))();\n            }\n        }, {\n            key: 'value',\n            value: function value(time) {\n                if (this.vs.length === 1) {\n                    return this.v1;\n                }\n                return this.vs;\n            }\n        }, {\n            key: 'at',\n            value: function at(time) {\n                time = this.transform(time);\n\n                this.vs = [];\n                for (var i = 0; i < this.bs.length; ++i) {\n                    var other = this.bs[i].switch(time).at(time);\n                    this['v' + (i + 1)] = other[0];\n                    this['b' + (i + 1)] = this.bs[i] = other[1];\n\n                    this.vs.push(other[0]);\n                }\n\n                var b = this.switch(time); // should this be done earlier?\n                return [b.value(time), b.behavior(time)];\n            }\n        }]);\n\n        return _class;\n    }(Behavior);\n}\n\nvar p = {};\nvar _exports = {};\nfunction createBCFunctions() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n\n    var _loop = function _loop(i) {\n        p['bc' + i] = function (name, valueFunction) {\n            p[name] = function (_BehaviorCombinator) {\n                _inherits(_class2, _BehaviorCombinator);\n\n                function _class2() {\n                    _classCallCheck(this, _class2);\n\n                    return _possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).apply(this, arguments));\n                }\n\n                _createClass(_class2, [{\n                    key: 'value',\n                    value: function value(time) {\n                        return valueFunction.apply(undefined, _toConsumableArray(this.vs.concat(this.as)));\n                    }\n                }]);\n\n                return _class2;\n            }(BehaviorCombinator(i));\n\n            _exports[name.toLowerCase()] = function () {\n                for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                    args[_key2] = arguments[_key2];\n                }\n\n                return new (Function.prototype.bind.apply(p[name], [null].concat(_toConsumableArray(args.map(lift)))))();\n            };\n        };\n    };\n\n    for (var i = 0; i < n; ++i) {\n        _loop(i);\n    }\n    p.bc = p.bc0; // alias\n}\ncreateBCFunctions();\n\np.bc0('AddV', function (v1, v2) {\n    return v1.add(v2);\n});\np.bc0('SubV', function (v1, v2) {\n    return v1.sub(v2);\n});\np.bc0('MulV', function (v1, v2) {\n    return v1.mul(v2);\n});\np.bc0('DivV', function (v1, v2) {\n    return v1.div(v2);\n});\n\np.bc0('AddB', function (v1, v2) {\n    return v1 + v2;\n});\np.bc0('SubB', function (v1, v2) {\n    return v1 - v2;\n});\np.bc0('MulB', function (v1, v2) {\n    return v1 * v2;\n});\np.bc0('DivB', function (v1, v2) {\n    return v1 / v2;\n});\n\np.bc0('Sin', function (v1) {\n    return Math.sin(v1);\n});\np.bc0('Cos', function (v1) {\n    return Math.cos(v1);\n});\n\np.bc0('Abs', function (v1) {\n    return Math.abs(v1);\n});\np.bc0('Comp', function (v1) {\n    return -undefined.v1;\n});\n\np.bc0('Squared', function (v1) {\n    return v1 * v1;\n});\np.bc0('Cubed', function (v1) {\n    return v1 * v1 * v1;\n});\n\np.bc0('Mod', function (v1, a1) {\n    return v1 % a1;\n});\n\np.bc1('GT', function (v1, a1) {\n    return v1 > a1;\n});\np.bc1('LT', function (v1, a1) {\n    return v1 < a1;\n});\np.bc1('GTE', function (v1, a1) {\n    return v1 >= a1;\n});\np.bc1('LTE', function (v1, a1) {\n    return v1 <= a1;\n});\np.bc1('Eq', function (v1, a1) {\n    return v1 == a1;\n});\n\np.bc1('Add', function (v1, a1) {\n    return v1 + a1;\n});\np.bc1('Sub', function (v1, a1) {\n    return v1 - a1;\n});\np.bc1('Mul', function (v1, a1) {\n    return v1 * a1;\n});\np.bc1('Div', function (v1, a1) {\n    return v1 / a1;\n});\n\np.bc2('Cond', function (v1, a1, a2) {\n    return v1 ? a1 : a2;\n});\n\nvar Later = function (_BehaviorCombinator2) {\n    _inherits(Later, _BehaviorCombinator2);\n\n    function Later() {\n        _classCallCheck(this, Later);\n\n        return _possibleConstructorReturn(this, (Later.__proto__ || Object.getPrototypeOf(Later)).apply(this, arguments));\n    }\n\n    _createClass(Later, [{\n        key: 'transform',\n        value: function transform(time) {\n            return time - this.a1;\n        }\n    }]);\n\n    return Later;\n}(BehaviorCombinator(1));\n\nvar UntilB = function (_BehaviorCombinator3) {\n    _inherits(UntilB, _BehaviorCombinator3);\n\n    function UntilB() {\n        _classCallCheck(this, UntilB);\n\n        return _possibleConstructorReturn(this, (UntilB.__proto__ || Object.getPrototypeOf(UntilB)).apply(this, arguments));\n    }\n\n    _createClass(UntilB, [{\n        key: 'switch',\n        value: function _switch(time) {\n            var occ = this.a1.occ();\n\n            if (occ[1] != null) {\n                return occ[1];\n            } else {\n                return this;\n            }\n        }\n    }]);\n\n    return UntilB;\n}(BehaviorCombinator(1));\n\nvar Transform = function (_BehaviorCombinator4) {\n    _inherits(Transform, _BehaviorCombinator4);\n\n    function Transform() {\n        _classCallCheck(this, Transform);\n\n        return _possibleConstructorReturn(this, (Transform.__proto__ || Object.getPrototypeOf(Transform)).apply(this, arguments));\n    }\n\n    _createClass(Transform, [{\n        key: 'value',\n        value: function value(time) {\n            return this.a1(this.v1);\n        }\n    }]);\n\n    return Transform;\n}(BehaviorCombinator(1));\n\nvar Mouse = function (_Behavior2) {\n    _inherits(Mouse, _Behavior2);\n\n    function Mouse() {\n        _classCallCheck(this, Mouse);\n\n        var _this6 = _possibleConstructorReturn(this, (Mouse.__proto__ || Object.getPrototypeOf(Mouse)).call(this));\n\n        _this6.pos = new Vector(0, 0);\n        return _this6;\n    }\n\n    _createClass(Mouse, [{\n        key: 'value',\n        value: function value(time) {\n            var _this7 = this;\n\n            var mouseAtStep = currentMouse;\n            var delay = g.loopTime - time;\n\n            timeout(function () {\n                _this7.pos = mouseAtStep;\n            }, delay);\n\n            return this.pos;\n        }\n    }]);\n\n    return Mouse;\n}(Behavior);\n\nvar MouseX = function (_Mouse) {\n    _inherits(MouseX, _Mouse);\n\n    function MouseX() {\n        _classCallCheck(this, MouseX);\n\n        return _possibleConstructorReturn(this, (MouseX.__proto__ || Object.getPrototypeOf(MouseX)).apply(this, arguments));\n    }\n\n    _createClass(MouseX, [{\n        key: 'value',\n        value: function value(time) {\n            return _get(MouseX.prototype.__proto__ || Object.getPrototypeOf(MouseX.prototype), 'value', this).call(this, time).x;\n        }\n    }]);\n\n    return MouseX;\n}(Mouse);\n\nvar MouseY = function (_Mouse2) {\n    _inherits(MouseY, _Mouse2);\n\n    function MouseY() {\n        _classCallCheck(this, MouseY);\n\n        return _possibleConstructorReturn(this, (MouseY.__proto__ || Object.getPrototypeOf(MouseY)).apply(this, arguments));\n    }\n\n    _createClass(MouseY, [{\n        key: 'value',\n        value: function value(time) {\n            return _get(MouseY.prototype.__proto__ || Object.getPrototypeOf(MouseY.prototype), 'value', this).call(this, time).y;\n        }\n    }]);\n\n    return MouseY;\n}(Mouse);\n\n// could be improved\n\n\nvar AccelMouse = function (_Behavior3) {\n    _inherits(AccelMouse, _Behavior3);\n\n    function AccelMouse(scalar) {\n        _classCallCheck(this, AccelMouse);\n\n        var _this10 = _possibleConstructorReturn(this, (AccelMouse.__proto__ || Object.getPrototypeOf(AccelMouse)).call(this));\n\n        var topSpeed = 5;\n        var position = new Vector();\n        var velocity = new Vector();\n\n        _this10.b = transform(mouse(), function (i) {\n            var mouse = new Vector(i.x, i.y);\n            var desired = mouse.sub(position);\n\n            var d = desired.mag();\n            desired = desired.inorm();\n\n            var acceleration = desired.mul(scalar);\n\n            velocity = velocity.add(acceleration).limit(topSpeed);\n            position = position.add(velocity);\n\n            return position;\n        });\n        return _this10;\n    }\n\n    _createClass(AccelMouse, [{\n        key: 'value',\n        value: function value(time) {\n            return this.b.at(time)[0];\n        }\n    }]);\n\n    return AccelMouse;\n}(Behavior);\n\n// should be removed and replaced with events\n\n\nvar GoToMouse = function (_Behavior4) {\n    _inherits(GoToMouse, _Behavior4);\n\n    function GoToMouse(scalar) {\n        _classCallCheck(this, GoToMouse);\n\n        var _this11 = _possibleConstructorReturn(this, (GoToMouse.__proto__ || Object.getPrototypeOf(GoToMouse)).call(this));\n\n        var topSpeed = 1;\n\n        var position = new Vector();\n        var velocity = new Vector();\n\n        _this11.b = transform(mouse(), function (i) {\n            var mouse = new Vector(i.x, i.y);\n            var direction = mouse.isub(position).inorm();\n\n            var acceleration = direction.mul(scalar);\n\n            velocity = velocity.add(acceleration).limit(topSpeed);\n            position = position.add(velocity);\n\n            return position;\n        });\n        return _this11;\n    }\n\n    _createClass(GoToMouse, [{\n        key: 'value',\n        value: function value(time) {\n            return this.b.at(time)[0];\n        }\n    }]);\n\n    return GoToMouse;\n}(Behavior);\n\nfunction lift(term) {\n    if (term.isBehavior) {\n        return term; // assume its a behavior already\n    }\n    if (typeof term !== 'function') {\n        return new Behavior(function (t) {\n            return term;\n        });\n    }\n    return new Behavior(term);\n}\n\nObject.assign(_exports, {\n    lift: lift,\n    at: function at(b, t) {\n        return lift(b).at(t);\n    },\n    later: function later(b, ms) {\n        return new Later(b, ms);\n    },\n    time: function time() {\n        return new Behavior(function (t) {\n            return t;\n        });\n    },\n    transform: function transform(b, f) {\n        return new Transform(b, f);\n    },\n    mouseX: function mouseX() {\n        return new MouseX();\n    },\n    mouseY: function mouseY() {\n        return new MouseY();\n    },\n    mouse: function mouse() {\n        return new Mouse();\n    },\n    accelMouseX: function accelMouseX(a) {\n        return new AccelMouseX(a);\n    },\n    accelMouseY: function accelMouseY(a) {\n        return new AccelMouseY(a);\n    },\n    accelMouse: function accelMouse(a) {\n        return new AccelMouse(a);\n    },\n    goToMouse: function goToMouse(a) {\n        return new GoToMouse(a);\n    },\n    untilB: function untilB(b, e) {\n        return new UntilB(b, e);\n    },\n    neg: p.comp // alias\n});\n\nexports.default = _exports;\n\n//# sourceURL=webpack:///./src/behaviors.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var require;\n\nvar _test = __webpack_require__(/*! ./test */ \"./src/test.js\");\n\nvar _test2 = _interopRequireDefault(_test);\n\nvar _behaviors = __webpack_require__(/*! ./behaviors */ \"./src/behaviors.js\");\n\nvar _behaviors2 = _interopRequireDefault(_behaviors);\n\nvar _arrowsEs = __webpack_require__(/*! expose-loader?LiftedArrow!../deps/arrows.es5.js */ \"./node_modules/expose-loader/index.js?LiftedArrow!./deps/arrows.es5.js-exposed\");\n\nvar _arrowsEs2 = _interopRequireDefault(_arrowsEs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nrequire = undefined;\n\n\nconsole.log(_arrowsEs2.default);\n\neval.call(null, _arrowsEs2.default);\n\nvar _exports = {\n    Behavior: _behaviors2.default.Behavior,\n    poo: 3\n};\n\nObject.assign(_exports, _behaviors2.default);\n\nfor (var key in _exports) {\n    window[key] = _exports[key];\n}\n\n//# sourceURL=webpack:///./src/main.js?");

/***/ }),

/***/ "./src/test.js":
/*!*********************!*\
  !*** ./src/test.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = {\n    meow: 'awoeifjaweoifj'\n};\n\n//# sourceURL=webpack:///./src/test.js?");

/***/ })

/******/ });